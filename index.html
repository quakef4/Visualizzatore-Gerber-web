<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gerber Viewer Pro v23</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        :root { --bg:#0c0c0c; --panel:#141414; --surface:#1e1e1e; --border:#2a2a2a; --text:#e0e0e0; --text2:#666; --accent:#22c55e; }
        * { margin:0; padding:0; box-sizing:border-box; }
        body { font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif; background:var(--bg); color:var(--text); height:100vh; overflow:hidden; }
        .app { display:grid; grid-template-columns:300px 1fr; grid-template-rows:50px 1fr; height:100vh; }
        header { grid-column:1/-1; background:var(--panel); border-bottom:1px solid var(--border); padding:0 20px; display:flex; align-items:center; justify-content:space-between; }
        .logo { font-weight:700; font-size:1.1rem; display:flex; align-items:center; gap:10px; }
        .logo-icon { width:32px; height:32px; background:linear-gradient(135deg,var(--accent),#16a34a); border-radius:8px; display:flex; align-items:center; justify-content:center; font-size:16px; color:#000; }
        .logo span { color:var(--accent); }
        .header-actions { display:flex; gap:8px; }
        .btn { padding:8px 16px; background:var(--surface); border:1px solid var(--border); border-radius:6px; color:var(--text); font-size:13px; cursor:pointer; transition:all .2s; }
        .btn:hover { border-color:var(--accent); color:var(--accent); }
        .btn.active { background:var(--accent); color:#000; border-color:var(--accent); }
        .sidebar { background:var(--panel); border-right:1px solid var(--border); overflow-y:auto; }
        .panel { border-bottom:1px solid var(--border); }
        .panel-header { padding:14px 16px; font-size:11px; font-weight:600; text-transform:uppercase; color:var(--accent); background:rgba(34,197,94,.08); cursor:pointer; display:flex; justify-content:space-between; align-items:center; }
        .panel-header:hover { background:rgba(34,197,94,.12); }
        .panel-body { padding:14px 16px; }
        .panel.collapsed .panel-body { display:none; }
        .dropzone { border:2px dashed var(--border); border-radius:10px; padding:24px 16px; text-align:center; cursor:pointer; transition:all .2s; }
        .dropzone:hover,.dropzone.over { border-color:var(--accent); background:rgba(34,197,94,.08); }
        .dropzone input { display:none; }
        .dropzone-icon { font-size:36px; margin-bottom:10px; }
        .dropzone-title { font-size:13px; font-weight:600; margin-bottom:4px; }
        .dropzone-subtitle { font-size:11px; color:var(--text2); }
        .file-list { max-height:100px; overflow-y:auto; margin-top:12px; }
        .file-item { display:flex; align-items:center; gap:8px; padding:8px 10px; background:var(--surface); border-radius:6px; margin-bottom:4px; font-size:11px; }
        .file-tag { font-size:9px; padding:3px 6px; border-radius:4px; font-weight:700; }
        .file-tag.copper { background:#92400e; color:#fef3c7; }
        .file-tag.mask { background:#15803d; color:#dcfce7; }
        .file-tag.silk { background:#525252; color:#fff; }
        .file-tag.drill { background:#1d4ed8; color:#dbeafe; }
        .file-tag.outline { background:#a16207; color:#fef9c3; }
        .file-tag.inner { background:#7c3aed; color:#ede9fe; }
        .file-name { flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
        .file-del { background:none; border:none; color:var(--text2); cursor:pointer; padding:4px 8px; border-radius:4px; }
        .file-del:hover { background:rgba(239,68,68,.2); color:#ef4444; }
        .layer-list { max-height:200px; overflow-y:auto; }
        .layer-item { display:flex; align-items:center; gap:10px; padding:10px 12px; cursor:pointer; border-radius:6px; font-size:12px; }
        .layer-item:hover { background:rgba(255,255,255,.04); }
        .layer-toggle { width:36px; height:18px; background:var(--bg); border:1px solid var(--border); border-radius:9px; position:relative; }
        .layer-toggle::after { content:''; position:absolute; top:2px; left:2px; width:12px; height:12px; background:var(--text2); border-radius:50%; transition:.2s; }
        .layer-toggle.on { background:var(--accent); border-color:var(--accent); }
        .layer-toggle.on::after { left:20px; background:#000; }
        .layer-color { width:16px; height:16px; border-radius:4px; border:1px solid rgba(255,255,255,.2); }
        .layer-name { flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
        .layer-actions { display:flex; gap:8px; margin-top:12px; }
        .layer-actions .btn { flex:1; justify-content:center; padding:8px; font-size:11px; }
        .view-section { margin-bottom:14px; }
        .view-label { font-size:10px; color:var(--text2); margin-bottom:8px; text-transform:uppercase; }
        .view-grid { display:grid; grid-template-columns:repeat(3,1fr); gap:6px; }
        .view-grid-2 { display:grid; grid-template-columns:repeat(2,1fr); gap:6px; }
        .view-btn { padding:10px 8px; background:var(--surface); border:1px solid var(--border); border-radius:6px; color:var(--text2); font-size:11px; cursor:pointer; transition:all .15s; }
        .view-btn:hover { border-color:var(--text); color:var(--text); }
        .view-btn.active { background:var(--accent); color:#000; border-color:var(--accent); }
        .copper-toggle { margin-top:12px; padding-top:12px; border-top:1px solid var(--border); }
        .copper-btn { width:100%; padding:10px; background:var(--surface); border:1px solid var(--border); border-radius:6px; color:var(--text2); font-size:11px; cursor:pointer; }
        .copper-btn:hover { border-color:#f59e0b; color:#f59e0b; }
        .copper-btn.active { background:#b45309; color:#fff; border-color:#b45309; }
        .color-presets { display:flex; gap:8px; flex-wrap:wrap; }
        .color-preset { width:40px; height:40px; border-radius:8px; border:2px solid transparent; cursor:pointer; }
        .color-preset:hover { transform:scale(1.1); }
        .color-preset.active { border-color:#fff; box-shadow:0 0 0 2px var(--accent); }
        .preset-green { background:linear-gradient(135deg,#14532d 50%,#b45309 50%); }
        .preset-blue { background:linear-gradient(135deg,#1e3a8a 50%,#b45309 50%); }
        .preset-red { background:linear-gradient(135deg,#991b1b 50%,#b45309 50%); }
        .preset-black { background:linear-gradient(135deg,#171717 50%,#b45309 50%); }
        .preset-white { background:linear-gradient(135deg,#f5f5f4 50%,#78350f 50%); }
        .preset-purple { background:linear-gradient(135deg,#581c87 50%,#b45309 50%); }
        .stats-grid { display:grid; grid-template-columns:1fr 1fr; gap:10px; }
        .stat-item { background:var(--surface); border-radius:8px; padding:12px; }
        .stat-label { font-size:10px; color:var(--text2); text-transform:uppercase; margin-bottom:4px; }
        .stat-value { font-size:15px; font-weight:700; color:var(--accent); }
        .drill-table { width:100%; font-size:11px; margin-top:12px; }
        .drill-table th { text-align:left; padding:8px; background:var(--surface); color:var(--text2); }
        .drill-table td { padding:8px; border-bottom:1px solid var(--border); }
        main { display:flex; flex-direction:column; background:var(--bg); }
        .toolbar { display:flex; align-items:center; gap:6px; padding:10px 16px; background:var(--panel); border-bottom:1px solid var(--border); flex-wrap:wrap; }
        .tool-btn { width:34px; height:34px; background:var(--surface); border:1px solid var(--border); border-radius:6px; color:var(--text2); cursor:pointer; font-size:16px; display:flex; align-items:center; justify-content:center; }
        .tool-btn:hover { border-color:var(--accent); color:var(--accent); }
        .tool-btn.active { background:var(--accent); color:#000; border-color:var(--accent); }
        .tool-sep { width:1px; height:24px; background:var(--border); margin:0 4px; }
        .zoom-display { font-size:12px; color:var(--text); min-width:55px; text-align:center; }
        .canvas-container { flex:1; position:relative; overflow:hidden; }
        #canvas2d { position:absolute; top:0; left:0; width:100%; height:100%; cursor:grab; }
        #canvas3d { position:absolute; top:0; left:0; width:100%; height:100%; display:none; }
        .empty-state { position:absolute; inset:0; display:flex; flex-direction:column; align-items:center; justify-content:center; color:var(--text2); }
        .empty-icon { font-size:72px; margin-bottom:20px; opacity:.2; }
        .empty-title { font-size:20px; margin-bottom:8px; color:var(--text); }
        .loading { position:absolute; inset:0; background:rgba(0,0,0,.9); display:none; place-items:center; z-index:100; }
        .loading.show { display:grid; }
        .spinner { width:44px; height:44px; border:3px solid var(--border); border-top-color:var(--accent); border-radius:50%; animation:spin .8s linear infinite; }
        @keyframes spin { to { transform:rotate(360deg); } }
        .measure-info { position:absolute; bottom:20px; left:50%; transform:translateX(-50%); background:var(--panel); border:1px solid var(--accent); border-radius:8px; padding:12px 20px; font-size:13px; display:none; z-index:50; }
        .measure-info.show { display:block; }
        .measure-value { color:var(--accent); font-weight:700; font-size:16px; }
        .drc-panel { position:fixed; right:20px; top:70px; width:320px; background:var(--panel); border:1px solid var(--border); border-radius:10px; z-index:200; display:none; max-height:calc(100vh - 100px); overflow-y:auto; }
        .drc-panel.show { display:block; }
        .drc-header { padding:14px 16px; background:rgba(239,68,68,.1); border-bottom:1px solid var(--border); display:flex; justify-content:space-between; align-items:center; }
        .drc-title { font-weight:600; color:#ef4444; }
        .drc-close { background:none; border:none; color:var(--text2); cursor:pointer; font-size:18px; }
        .drc-body { padding:14px 16px; }
        .drc-item { padding:10px; background:var(--surface); border-radius:6px; margin-bottom:8px; font-size:12px; border-left:3px solid #ef4444; }
        .drc-item.warning { border-left-color:#f59e0b; }
        .drc-item.info { border-left-color:#3b82f6; }
        .drc-item-title { font-weight:600; margin-bottom:4px; }
        .drc-item-desc { color:var(--text2); }
        .drc-summary { padding:12px; background:var(--surface); border-radius:6px; margin-bottom:12px; }
        .drc-summary-title { font-size:11px; color:var(--text2); margin-bottom:6px; }
        .drc-counts { display:flex; gap:16px; }
        .drc-count { text-align:center; }
        .drc-count-num { font-size:20px; font-weight:700; }
        .drc-count-label { font-size:10px; color:var(--text2); }
        .drc-count.error .drc-count-num { color:#ef4444; }
        .drc-count.warning .drc-count-num { color:#f59e0b; }
        .drc-count.ok .drc-count-num { color:var(--accent); }
        .dropdown { position:relative; display:inline-block; }
        .dropdown-content { display:none; position:absolute; top:100%; left:0; background:var(--panel); border:1px solid var(--border); border-radius:6px; min-width:160px; z-index:100; margin-top:4px; }
        .dropdown:hover .dropdown-content { display:block; }
        .dropdown-item { padding:10px 14px; font-size:12px; cursor:pointer; display:flex; align-items:center; gap:8px; }
        .dropdown-item:hover { background:rgba(34,197,94,.1); color:var(--accent); }
        .netlist-panel { position:fixed; right:20px; top:70px; width:360px; background:var(--panel); border:1px solid var(--border); border-radius:10px; z-index:200; display:none; max-height:calc(100vh - 100px); overflow-y:auto; }
        .netlist-panel.show { display:block; }
        .netlist-header { padding:14px 16px; background:rgba(34,197,94,.08); border-bottom:1px solid var(--border); display:flex; justify-content:space-between; align-items:center; }
        .netlist-title { font-weight:600; color:var(--accent); }
        .net-item { padding:10px 16px; border-bottom:1px solid var(--border); font-size:12px; cursor:pointer; }
        .net-item:hover { background:rgba(34,197,94,.05); }
        .net-name { font-weight:600; color:var(--accent); }
        .net-pads { color:var(--text2); margin-top:4px; }
    </style>
</head>
<body>
<div class="app">
    <header>
        <div class="logo"><div class="logo-icon">&#9643;</div>Gerber<span>Viewer</span><small style="color:var(--text2);margin-left:8px">v23</small></div>
        <div class="header-actions">
            <button class="btn" id="btnDRC">&#128269; DRC</button>
            <button class="btn" id="btnNetlist">&#128279; Netlist</button>
            <div class="dropdown">
                <button class="btn" id="btnExport">&#128190; Esporta &#9662;</button>
                <div class="dropdown-content">
                    <div class="dropdown-item" id="exportPng">&#128247; PNG</div>
                    <div class="dropdown-item" id="exportSvg">&#128196; SVG</div>
                </div>
            </div>
            <button class="btn" id="btnClear">&#128465; Pulisci</button>
        </div>
    </header>

    <aside class="sidebar">
        <div class="panel">
            <div class="panel-header">&#128193; File Gerber</div>
            <div class="panel-body">
                <div class="dropzone" id="dropzone">
                    <div class="dropzone-icon">&#128194;</div>
                    <div class="dropzone-title">Trascina file o clicca</div>
                    <div class="dropzone-subtitle">Gerber, Excellon, ZIP</div>
                    <input type="file" id="fileInput" multiple>
                </div>
                <div class="file-list" id="fileList"></div>
            </div>
        </div>

        <div class="panel">
            <div class="panel-header">&#128450; Layer (<span id="layerCount">0</span>)</div>
            <div class="panel-body">
                <div class="layer-list" id="layerList"></div>
                <div class="layer-actions">
                    <button class="btn" id="btnShowAll">&#128065; Tutti</button>
                    <button class="btn" id="btnHideAll">&#128683; Nessuno</button>
                </div>
            </div>
        </div>

        <div class="panel">
            <div class="panel-header">&#128065; Vista</div>
            <div class="panel-body">
                <div class="view-section">
                    <div class="view-label">Modalita</div>
                    <div class="view-grid-2">
                        <button class="view-btn active" data-mode="2d">2D</button>
                        <button class="view-btn" data-mode="3d">3D</button>
                    </div>
                </div>
                <div class="view-section">
                    <div class="view-label">Lato</div>
                    <div class="view-grid">
                        <button class="view-btn active" data-view="top">Top</button>
                        <button class="view-btn" data-view="bottom">Bottom</button>
                        <button class="view-btn" data-view="all">Tutti</button>
                    </div>
                </div>
                <div class="view-section">
                    <div class="view-label">Rotazione</div>
                    <div class="view-grid">
                        <button class="view-btn active" data-rot="0">0&#176;</button>
                        <button class="view-btn" data-rot="90">90&#176;</button>
                        <button class="view-btn" data-rot="180">180&#176;</button>
                    </div>
                </div>
                <div class="copper-toggle">
                    <button class="copper-btn" id="btnCopperOnly">&#128310; Solo Rame</button>
                </div>
            </div>
        </div>

        <div class="panel">
            <div class="panel-header">&#127912; Colori PCB</div>
            <div class="panel-body">
                <div class="color-presets">
                    <div class="color-preset preset-green active" data-mask="#14532d" data-silk="#f5f5f4" title="Verde"></div>
                    <div class="color-preset preset-blue" data-mask="#1e3a8a" data-silk="#f5f5f4" title="Blu"></div>
                    <div class="color-preset preset-red" data-mask="#991b1b" data-silk="#f5f5f4" title="Rosso"></div>
                    <div class="color-preset preset-black" data-mask="#171717" data-silk="#f5f5f4" title="Nero"></div>
                    <div class="color-preset preset-white" data-mask="#f5f5f4" data-silk="#171717" title="Bianco"></div>
                    <div class="color-preset preset-purple" data-mask="#581c87" data-silk="#f5f5f4" title="Viola"></div>
                </div>
            </div>
        </div>

        <div class="panel">
            <div class="panel-header">&#128200; Statistiche</div>
            <div class="panel-body">
                <div class="stats-grid">
                    <div class="stat-item"><div class="stat-label">Dimensione</div><div class="stat-value" id="statSize">-</div></div>
                    <div class="stat-item"><div class="stat-label">Fori</div><div class="stat-value" id="statHoles">-</div></div>
                    <div class="stat-item"><div class="stat-label">Layer</div><div class="stat-value" id="statLayers">-</div></div>
                    <div class="stat-item"><div class="stat-label">Net</div><div class="stat-value" id="statNets">-</div></div>
                </div>
                <table class="drill-table" id="drillTable" style="display:none">
                    <thead><tr><th>Tool</th><th>&#216; mm</th><th>Qty</th></tr></thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
    </aside>

    <main>
        <div class="toolbar">
            <button class="tool-btn" id="btnZoomIn" title="Zoom +">+</button>
            <button class="tool-btn" id="btnZoomOut" title="Zoom -">&#8722;</button>
            <button class="tool-btn" id="btnFit" title="Adatta">&#8865;</button>
            <span class="zoom-display" id="zoomDisplay">100%</span>
            <div class="tool-sep"></div>
            <button class="tool-btn" id="btnFlipH" title="Specchia H">&#8596;</button>
            <button class="tool-btn" id="btnFlipV" title="Specchia V">&#8597;</button>
            <div class="tool-sep"></div>
            <button class="tool-btn" id="btnMeasure" title="Misura distanza">&#128207;</button>
        </div>
        <div class="canvas-container" id="canvasContainer">
            <canvas id="canvas2d" style="display:none"></canvas>
            <div id="canvas3d"></div>
            <div class="empty-state" id="emptyState">
                <div class="empty-icon">&#9643;</div>
                <div class="empty-title">Carica file Gerber</div>
                <div>Trascina file o usa il pannello laterale</div>
            </div>
            <div class="loading" id="loading"><div class="spinner"></div></div>
            <div class="measure-info" id="measureInfo">
                Distanza: <span class="measure-value" id="measureValue">0.00 mm</span>
            </div>
        </div>
    </main>
</div>

<div class="drc-panel" id="drcPanel">
    <div class="drc-header">
        <span class="drc-title">&#128269; Design Rule Check</span>
        <button class="drc-close" id="drcClose">&#10005;</button>
    </div>
    <div class="drc-body" id="drcBody">
        <div class="drc-summary">
            <div class="drc-summary-title">Riepilogo</div>
            <div class="drc-counts">
                <div class="drc-count error"><div class="drc-count-num" id="drcErrors">0</div><div class="drc-count-label">Errori</div></div>
                <div class="drc-count warning"><div class="drc-count-num" id="drcWarnings">0</div><div class="drc-count-label">Avvisi</div></div>
                <div class="drc-count ok"><div class="drc-count-num" id="drcOk">0</div><div class="drc-count-label">OK</div></div>
            </div>
        </div>
        <div id="drcResults"></div>
    </div>
</div>

<div class="netlist-panel" id="netlistPanel">
    <div class="netlist-header">
        <span class="netlist-title">&#128279; Netlist</span>
        <button class="drc-close" id="netlistClose">&#10005;</button>
    </div>
    <div id="netlistBody"></div>
</div>

<script>
class GerberViewer {
    constructor() {
        this.canvas2d = document.getElementById('canvas2d');
        this.ctx = this.canvas2d.getContext('2d');
        this.files = [];
        this.layers = [];
        this.bounds = null;
        this.boardOutline = null;
        this.zoom = 1;
        this.pan = {x:0, y:0};
        this.ppm = 10;
        this.rotation = 0;
        this.flipH = false;
        this.flipV = false;
        this.colors = { bg:'#0c0c0c', mask:'#14532d', silk:'#f5f5f4', copper:'#b45309', fr4:'#c19a6b' };
        this.copperOnly = false;
        this.mode = '2d';
        this.currentView = 'top';

        // Measure tool
        this.measuring = false;
        this.measureStart = null;
        this.measureEnd = null;

        // 3D
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.controls = null;
        this.pcbMesh = null;

        // Gerber X2 attributes
        this.x2Attributes = {};

        // Netlist
        this.nets = [];
        this.pads = [];

        // DRC results
        this.drcResults = [];

        this.setupEvents();
    }

    setupEvents() {
        const dropzone = document.getElementById('dropzone');
        const fileInput = document.getElementById('fileInput');

        dropzone.onclick = () => fileInput.click();
        dropzone.ondragover = e => { e.preventDefault(); dropzone.classList.add('over'); };
        dropzone.ondragleave = () => dropzone.classList.remove('over');
        dropzone.ondrop = e => { e.preventDefault(); dropzone.classList.remove('over'); this.loadFiles(e.dataTransfer.files); };
        fileInput.onchange = () => this.loadFiles(fileInput.files);

        document.getElementById('btnClear').onclick = () => this.clear();
        document.getElementById('exportPng').onclick = () => this.exportPng();
        document.getElementById('exportSvg').onclick = () => this.exportSvg();
        document.getElementById('btnShowAll').onclick = () => this.setAllLayersVisible(true);
        document.getElementById('btnHideAll').onclick = () => this.setAllLayersVisible(false);
        document.getElementById('btnZoomIn').onclick = () => this.setZoom(this.zoom*1.3);
        document.getElementById('btnZoomOut').onclick = () => this.setZoom(this.zoom/1.3);
        document.getElementById('btnFit').onclick = () => this.fit();
        document.getElementById('btnFlipH').onclick = () => { this.flipH=!this.flipH; this.render(); };
        document.getElementById('btnFlipV').onclick = () => { this.flipV=!this.flipV; this.render(); };

        document.getElementById('btnMeasure').onclick = () => {
            this.measuring = !this.measuring;
            document.getElementById('btnMeasure').classList.toggle('active', this.measuring);
            this.canvas2d.style.cursor = this.measuring ? 'crosshair' : 'grab';
            if (!this.measuring) {
                this.measureStart = null;
                this.measureEnd = null;
                document.getElementById('measureInfo').classList.remove('show');
                this.render();
            }
        };

        document.getElementById('btnDRC').onclick = () => {
            this.runDRC();
            document.getElementById('drcPanel').classList.toggle('show');
        };
        document.getElementById('drcClose').onclick = () => document.getElementById('drcPanel').classList.remove('show');

        document.getElementById('btnNetlist').onclick = () => {
            this.updateNetlistPanel();
            document.getElementById('netlistPanel').classList.toggle('show');
        };
        document.getElementById('netlistClose').onclick = () => document.getElementById('netlistPanel').classList.remove('show');

        document.getElementById('btnCopperOnly').onclick = () => {
            this.copperOnly = !this.copperOnly;
            document.getElementById('btnCopperOnly').classList.toggle('active', this.copperOnly);
            this.render();
            if (this.mode === '3d') this.update3D();
        };

        document.querySelectorAll('.view-btn[data-mode]').forEach(btn => {
            btn.onclick = () => {
                document.querySelectorAll('.view-btn[data-mode]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                this.setMode(btn.dataset.mode);
            };
        });

        document.querySelectorAll('.view-btn[data-view]').forEach(btn => {
            btn.onclick = () => {
                document.querySelectorAll('.view-btn[data-view]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                this.setView(btn.dataset.view);
            };
        });

        document.querySelectorAll('.view-btn[data-rot]').forEach(btn => {
            btn.onclick = () => {
                document.querySelectorAll('.view-btn[data-rot]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                this.rotation = parseInt(btn.dataset.rot);
                this.render();
            };
        });

        document.querySelectorAll('.color-preset').forEach(preset => {
            preset.onclick = () => {
                document.querySelectorAll('.color-preset').forEach(p => p.classList.remove('active'));
                preset.classList.add('active');
                this.colors.mask = preset.dataset.mask;
                this.colors.silk = preset.dataset.silk;
                this.layers.forEach(l => {
                    if (l.type==='mask') l.color = this.colors.mask;
                    if (l.type==='silk') l.color = this.colors.silk;
                });
                this.updateLayerList();
                this.render();
                if (this.mode === '3d') this.update3D();
            };
        });

        const container = document.getElementById('canvasContainer');
        container.onwheel = e => {
            if (this.mode === '2d') {
                e.preventDefault();
                this.setZoom(this.zoom * (e.deltaY < 0 ? 1.15 : 0.87));
            }
        };

        container.onmousedown = e => {
            if (this.mode !== '2d') return;
            if (this.measuring) {
                const coords = this.screenToWorld(e.clientX, e.clientY);
                if (!this.measureStart) {
                    this.measureStart = coords;
                } else {
                    this.measureEnd = coords;
                    this.showMeasurement();
                    this.render();
                }
                return;
            }
            this.drag = true;
            this.lastMouse = {x:e.clientX, y:e.clientY};
            this.canvas2d.style.cursor = 'grabbing';
        };

        container.onmousemove = e => {
            if (this.mode !== '2d') return;
            if (this.measuring && this.measureStart && !this.measureEnd) {
                this.measureEnd = this.screenToWorld(e.clientX, e.clientY);
                this.showMeasurement();
                this.render();
                this.measureEnd = null;
            }
            if (!this.drag) return;
            this.pan.x += e.clientX - this.lastMouse.x;
            this.pan.y += e.clientY - this.lastMouse.y;
            this.render();
            this.lastMouse = {x:e.clientX, y:e.clientY};
        };

        container.onmouseup = container.onmouseleave = () => {
            if (this.mode !== '2d') return;
            this.drag = false;
            if (!this.measuring) this.canvas2d.style.cursor = 'grab';
        };

        window.onresize = () => {
            if (this.layers.length) {
                if (this.mode === '2d') this.fit();
                else this.resize3D();
            }
        };
    }

    screenToWorld(screenX, screenY) {
        const rect = this.canvas2d.getBoundingClientRect();
        const canvasX = screenX - rect.left;
        const canvasY = screenY - rect.top;

        const scale = this.ppm * this.zoom;
        const bw = this.bounds.maxX - this.bounds.minX;
        const bh = this.bounds.maxY - this.bounds.minY;

        let x = (canvasX - this.pan.x) / scale + this.bounds.minX;
        let y = (canvasY - this.pan.y) / scale;
        // Correct for Y-flip (Gerber Y grows up, canvas Y grows down)
        y = bh - y + this.bounds.minY;

        return { x, y };
    }

    showMeasurement() {
        if (!this.measureStart || !this.measureEnd) return;
        const dx = this.measureEnd.x - this.measureStart.x;
        const dy = this.measureEnd.y - this.measureStart.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        document.getElementById('measureValue').textContent = dist.toFixed(3) + ' mm';
        document.getElementById('measureInfo').classList.add('show');
    }

    setMode(mode) {
        this.mode = mode;
        if (mode === '2d') {
            this.canvas2d.style.display = 'block';
            document.getElementById('canvas3d').style.display = 'none';
            this.stop3DAnimation();
            this.fit();
        } else {
            this.canvas2d.style.display = 'none';
            document.getElementById('canvas3d').style.display = 'block';
            this.init3D();
            this.update3D();
            this.start3DAnimation();
        }
    }

    stop3DAnimation() {
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
        }
    }

    start3DAnimation() {
        if (this.animationId) return;
        const animate = () => {
            if (this.mode !== '3d') {
                this.animationId = null;
                return;
            }
            this.animationId = requestAnimationFrame(animate);
            if (this.controls) this.controls.update();
            if (this.renderer && this.scene && this.camera) {
                this.renderer.render(this.scene, this.camera);
            }
        };
        animate();
    }

    setView(view) {
        this.currentView = view;
        this.layers.forEach(l => {
            if (view === 'all') l.visible = true;
            else if (view === 'top') l.visible = l.side === 'top' || l.side === 'both';
            else if (view === 'bottom') l.visible = l.side === 'bottom' || l.side === 'both';
        });
        this.updateLayerList();
        this.render();
        if (this.mode === '3d') this.update3D();
    }

    async loadFiles(fileList) {
        document.getElementById('loading').classList.add('show');
        const files = [];
        for (const f of fileList) {
            if (f.name.toLowerCase().endsWith('.zip')) files.push(...await this.extractZip(f));
            else files.push(f);
        }
        for (const f of files) {
            try {
                const text = await f.text();
                const layer = this.parseFile(f.name, text);
                if (layer?.cmds.length > 0) { this.files.push(f); this.layers.push(layer); }
            } catch(e) { console.error('Parse error:', f.name, e); }
        }
        this.extractBoardOutline();
        this.calcBounds();
        this.extractNets();
        this.updateUI();
        this.updateStats();
        if (this.layers.length > 0) {
            document.getElementById('emptyState').style.display = 'none';
            this.canvas2d.style.display = 'block';
            // Apply default TOP view
            this.setView('top');
            this.fit();
        }
        document.getElementById('loading').classList.remove('show');
    }

    async extractZip(zipFile) {
        const zip = await JSZip.loadAsync(zipFile);
        const files = [];
        const ext = ['gtl','gbl','gts','gbs','gto','gbo','drl','xln','gko','gm1','gbr','ger','gtp','gbp','txt','gdl','gme','g1','g2','g3','g4','g5','g6','gp1','gp2','gin','gp'];
        for (const [name, entry] of Object.entries(zip.files)) {
            if (!entry.dir && ext.includes(name.split('.').pop().toLowerCase())) {
                files.push(new File([await entry.async('string')], name.split('/').pop()));
            }
        }
        return files;
    }

    detectLayerType(name, ext, x2FileFunction) {
        const n = name.toLowerCase();

        // Gerber X2: use file function attribute if present
        if (x2FileFunction) {
            const func = x2FileFunction.toLowerCase();
            if (func.includes('copper') && func.includes('top')) return {type:'copper',side:'top',order:10};
            if (func.includes('copper') && func.includes('bot')) return {type:'copper',side:'bottom',order:11};
            if (func.includes('copper') && func.includes('inr')) {
                const match = func.match(/l(\d+)/i);
                const layerNum = match ? parseInt(match[1]) : 2;
                return {type:'inner',side:'inner',order:10 + layerNum * 0.1};
            }
            if (func.includes('soldermask') && func.includes('top')) return {type:'mask',side:'top',order:20};
            if (func.includes('soldermask') && func.includes('bot')) return {type:'mask',side:'bottom',order:21};
            if (func.includes('legend') && func.includes('top')) return {type:'silk',side:'top',order:30};
            if (func.includes('legend') && func.includes('bot')) return {type:'silk',side:'bottom',order:31};
            if (func.includes('profile') || func.includes('outline')) return {type:'outline',side:'both',order:0};
            if (func.includes('plated') || func.includes('drill')) return {type:'drill',side:'both',order:50};
        }

        // Traditional detection
        if (n.includes('toplayer') || n.includes('top_copper') || n.includes('-f_cu') || n.includes('top.g') || ext==='gtl') return {type:'copper',side:'top',order:10};
        if (n.includes('bottomlayer') || n.includes('bottom_copper') || n.includes('-b_cu') || n.includes('bottom.g') || ext==='gbl') return {type:'copper',side:'bottom',order:11};

        // Inner layers
        if (n.includes('inner') || n.includes('inr') || n.match(/in\d+/) || n.match(/layer[_\s]?\d/) || ext.match(/^g\d$/)) {
            const match = n.match(/(\d+)/);
            const layerNum = match ? parseInt(match[1]) : 2;
            return {type:'inner',side:'inner',order:10 + layerNum * 0.1};
        }
        if (ext === 'g2' || ext === 'g3' || ext === 'g4' || ext === 'g5' || ext === 'g6' || ext === 'gin' || ext === 'gp1' || ext === 'gp2') {
            const match = ext.match(/(\d+)/);
            const layerNum = match ? parseInt(match[1]) : 2;
            return {type:'inner',side:'inner',order:10 + layerNum * 0.1};
        }

        if (n.includes('topsoldermask') || n.includes('topmask') || n.includes('-f_mask') || ext==='gts') return {type:'mask',side:'top',order:20};
        if (n.includes('bottomsoldermask') || n.includes('bottommask') || n.includes('-b_mask') || ext==='gbs') return {type:'mask',side:'bottom',order:21};
        if (n.includes('topsilk') || n.includes('-f_silks') || ext==='gto') return {type:'silk',side:'top',order:30};
        if (n.includes('bottomsilk') || n.includes('-b_silks') || ext==='gbo') return {type:'silk',side:'bottom',order:31};
        if (n.includes('outline') || n.includes('edge') || n.includes('boardoutline') || n.includes('profile') || ext==='gko' || ext==='gm1') return {type:'outline',side:'both',order:0};
        if (n.includes('drill') || ext==='drl' || ext==='xln') return {type:'drill',side:'both',order:50};
        return {type:'unknown',side:'both',order:100};
    }

    getLayerColor(type) {
        const colors = {
            copper: this.colors.copper,
            mask: this.colors.mask,
            silk: this.colors.silk,
            outline: '#facc15',
            inner: '#cd7f32'  // Bronze for inner layers
        };
        return colors[type] || '#666';
    }

    parseFile(name, text) {
        const ext = name.toLowerCase().split('.').pop();

        // Parse Gerber X2 attributes first
        let x2FileFunction = null;
        const x2Match = text.match(/%TF\.FileFunction,([^*%]+)\*/);
        if (x2Match) {
            x2FileFunction = x2Match[1];
            this.x2Attributes[name] = { fileFunction: x2FileFunction };
        }

        const info = this.detectLayerType(name, ext, x2FileFunction);
        info.color = this.getLayerColor(info.type);

        const isDrill = (ext==='drl' || ext==='xln' || text.includes('M48'));

        return isDrill ? this.parseDrill(name, text, info) : this.parseGerber(name, text, info);
    }

    parseGerber(name, text, info) {
        // Format defaults
        let xInt = 2, xDec = 4, unit = 'mm';
        const apertures = {};
        const macros = {};
        let curAp = null, x = 0, y = 0, interp = 'linear', polarity = 'dark';
        let inRegion = false, regionPts = [];
        const cmds = [];

        // Gerber X2 attributes
        let apertureFunction = null;
        const netNames = new Map();

        // Calculate coordinate divisor based on decimal places
        const getScale = () => Math.pow(10, xDec) * (unit === 'in' ? 1/25.4 : 1);

        // Parse coordinate string to mm
        const parseCoord = (s) => {
            if (!s) return null;
            const neg = s.startsWith('-');
            if (neg) s = s.slice(1);
            // Pad to full length
            s = s.padStart(xInt + xDec, '0');
            const intPart = s.slice(0, s.length - xDec);
            const decPart = s.slice(s.length - xDec);
            let val = parseFloat(intPart + '.' + decPart);
            if (neg) val = -val;
            return unit === 'in' ? val * 25.4 : val;
        };

        // First pass: extract macros
        const macroRegex = /%AM([A-Za-z_][A-Za-z0-9_]*)\*([^%]*?)%/gs;
        let match;
        while ((match = macroRegex.exec(text)) !== null) {
            macros[match[1]] = match[2];
        }

        // Process lines
        const lines = text.split(/\r?\n/);
        for (const line of lines) {
            const l = line.trim();
            if (!l || l.startsWith('G04')) continue;

            // Gerber X2: File attributes
            let m = l.match(/%TF\.([^,*]+),?([^*%]*)\*%?/);
            if (m) {
                this.x2Attributes[name] = this.x2Attributes[name] || {};
                this.x2Attributes[name][m[1]] = m[2];
                continue;
            }

            // Gerber X2: Aperture attributes
            m = l.match(/%TA\.AperFunction,([^*%]+)\*%?/);
            if (m) {
                apertureFunction = m[1];
                continue;
            }

            // Gerber X2: Net name
            m = l.match(/%TO\.N,([^*%]+)\*%?/);
            if (m) {
                netNames.set('current', m[1]);
                continue;
            }

            // Gerber X2: Component
            m = l.match(/%TO\.C,([^*%]+)\*%?/);
            if (m) {
                // Store component reference
                continue;
            }

            // Delete attributes
            if (l.includes('%TD')) {
                apertureFunction = null;
                netNames.delete('current');
                continue;
            }

            // Format spec: %FSLAX45Y45*%
            m = l.match(/%FSLAX(\d)(\d)Y\d+\*%/);
            if (m) { xInt = +m[1]; xDec = +m[2]; continue; }

            // Unit
            if (l.includes('%MOMM')) { unit = 'mm'; continue; }
            if (l.includes('%MOIN')) { unit = 'in'; continue; }

            // Standard aperture: %ADD10C,0.5*% or %ADD10R,1.0X0.5*%
            m = l.match(/%ADD(\d+)([CROP]),?([^*]*)\*%/);
            if (m) {
                const num = m[1], type = m[2];
                const params = m[3] ? m[3].split('X').map(Number) : [0];
                apertures[num] = { type, params, rotation: 0, function: apertureFunction };
                continue;
            }

            // Macro aperture: %ADD12MACRO1,0.5X0.8X90*%
            m = l.match(/%ADD(\d+)([A-Za-z_][A-Za-z0-9_]*),?([^*]*)\*%/);
            if (m && !['C','R','O','P'].includes(m[2])) {
                const num = m[1], macroName = m[2];
                const params = m[3] ? m[3].split('X').map(Number) : [];

                if (macros[macroName]) {
                    apertures[num] = this.evaluateMacro(macros[macroName], params);
                    apertures[num].function = apertureFunction;
                } else {
                    // Unknown macro, fallback
                    apertures[num] = { type: 'C', params: [0.5], rotation: 0, function: apertureFunction };
                }
                continue;
            }

            // Polarity
            if (l.includes('%LPD')) { polarity = 'dark'; continue; }
            if (l.includes('%LPC')) { polarity = 'clear'; continue; }

            // Process commands
            for (const cmd of l.split('*').filter(c => c.trim())) {
                const c = cmd.trim();

                // Interpolation mode
                if (c === 'G01' || c === 'G1') { interp = 'linear'; continue; }
                if (c === 'G02' || c === 'G2') { interp = 'cw'; continue; }
                if (c === 'G03' || c === 'G3') { interp = 'ccw'; continue; }
                if (c === 'G74' || c === 'G75') continue;

                // Region
                if (c === 'G36') { inRegion = true; regionPts = []; continue; }
                if (c === 'G37') {
                    if (regionPts.length >= 3) {
                        cmds.push({ type: 'region', points: [...regionPts], polarity, net: netNames.get('current') });
                    }
                    inRegion = false;
                    continue;
                }

                // Aperture select: D10, D11, etc.
                m = c.match(/^D(\d+)$/);
                if (m && +m[1] >= 10) { curAp = m[1]; continue; }

                // Coordinate move/draw
                m = c.match(/^(?:G0?([123]))?(?:X(-?\d+))?(?:Y(-?\d+))?(?:I(-?\d+))?(?:J(-?\d+))?(?:D0?([123]))?$/);
                if (m && (m[2] || m[3] || m[6])) {
                    // Update interpolation if specified
                    if (m[1]) {
                        if (m[1] === '1') interp = 'linear';
                        else if (m[1] === '2') interp = 'cw';
                        else if (m[1] === '3') interp = 'ccw';
                    }

                    const ox = x, oy = y;
                    if (m[2]) x = parseCoord(m[2]);
                    if (m[3]) y = parseCoord(m[3]);
                    const i = m[4] ? parseCoord(m[4]) : 0;
                    const j = m[5] ? parseCoord(m[5]) : 0;
                    const d = m[6] ? +m[6] : null;

                    if (inRegion) {
                        if (d === 2) {
                            // Move - start new region
                            if (regionPts.length >= 3) {
                                cmds.push({ type: 'region', points: [...regionPts], polarity, net: netNames.get('current') });
                            }
                            regionPts = [{ x, y }];
                        } else if (d === 1 || d === null) {
                            if (!regionPts.length) regionPts.push({ x: ox, y: oy });
                            if (interp === 'linear') {
                                regionPts.push({ x, y });
                            } else {
                                regionPts.push(...this.arcToPoints(ox, oy, x, y, i, j, interp === 'cw'));
                            }
                        }
                    } else {
                        if (d === 1) {
                            // Draw
                            const ap = apertures[curAp] || { type: 'C', params: [0.1] };
                            if (interp === 'linear') {
                                cmds.push({ type: 'line', x1: ox, y1: oy, x2: x, y2: y, width: ap.params[0] || 0.1, polarity, net: netNames.get('current') });
                            } else {
                                cmds.push({ type: 'arc', x1: ox, y1: oy, x2: x, y2: y, i, j, cw: interp === 'cw', width: ap.params[0] || 0.1, polarity, net: netNames.get('current') });
                            }
                        } else if (d === 3) {
                            // Flash
                            const ap = apertures[curAp] || { type: 'C', params: [0.5] };
                            cmds.push({ type: 'flash', x, y, aperture: ap, polarity, net: netNames.get('current') });

                            // Store pad for netlist
                            if (info.type === 'copper') {
                                this.pads.push({ x, y, aperture: ap, net: netNames.get('current'), layer: info.side });
                            }
                        }
                    }
                }
            }
        }

        console.log(`[${name}] Format: ${xInt}.${xDec}, Unit: ${unit}, Apertures: ${Object.keys(apertures).length}, Commands: ${cmds.length}`);
        return { name, ...info, cmds, visible: true };
    }

    evaluateMacro(macroBody, params) {
        // Parse macro primitives and evaluate with parameters
        const primitives = macroBody.split('*').filter(p => p.trim());

        // Function to evaluate expression with $n variables
        const evalExpr = (expr) => {
            if (expr === undefined || expr === null) return 0;
            let s = String(expr).trim();
            // Replace $n with parameter values
            s = s.replace(/\$(\d+)/g, (_, n) => {
                const idx = parseInt(n) - 1;
                return params[idx] !== undefined ? params[idx] : 0;
            });
            // Handle 'x' as multiply
            s = s.replace(/x/gi, '*');
            try {
                return eval(s);
            } catch {
                return parseFloat(s) || 0;
            }
        };

        for (const prim of primitives) {
            const p = prim.trim();
            if (!p || p.startsWith('0')) continue; // Skip comments

            const parts = p.split(',');
            const code = parseInt(parts[0]);

            if (code === 1) {
                // Circle: 1,exposure,diameter,cx,cy[,rotation]
                const d = evalExpr(parts[2]);
                return { type: 'C', params: [d], rotation: 0 };
            } else if (code === 4) {
                // Outline: 4,exposure,n_vertices,x0,y0,x1,y1,...,rotation
                const nVerts = parseInt(parts[2]) || 0;
                const vertices = [];
                for (let i = 0; i <= nVerts; i++) {
                    vertices.push({
                        x: evalExpr(parts[3 + i * 2]),
                        y: evalExpr(parts[4 + i * 2])
                    });
                }
                // Calculate bounding box
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                for (const v of vertices) {
                    if (v.x < minX) minX = v.x;
                    if (v.y < minY) minY = v.y;
                    if (v.x > maxX) maxX = v.x;
                    if (v.y > maxY) maxY = v.y;
                }
                return { type: 'POLY', params: [maxX - minX, maxY - minY], vertices, rotation: 0 };
            } else if (code === 5) {
                // Polygon: 5,exposure,n_vertices,cx,cy,diameter,rotation
                const nVerts = parseInt(evalExpr(parts[2])) || 4;
                const d = evalExpr(parts[5]);
                const rot = evalExpr(parts[6]) || 0;
                return { type: 'P', params: [d, nVerts, rot], rotation: 0 };
            } else if (code === 20 || code === 2) {
                // Vector line: 20,exposure,width,x1,y1,x2,y2,rotation
                const w = evalExpr(parts[2]);
                return { type: 'C', params: [w], rotation: 0 };
            } else if (code === 21) {
                // Center rectangle: 21,exposure,width,height,cx,cy,rotation
                const w = evalExpr(parts[2]);
                const h = evalExpr(parts[3]);
                const rot = evalExpr(parts[6]) || 0;
                return { type: 'R', params: [w, h], rotation: rot };
            } else if (code === 22) {
                // Lower-left rectangle: 22,exposure,width,height,x,y,rotation
                const w = evalExpr(parts[2]);
                const h = evalExpr(parts[3]);
                const rot = evalExpr(parts[6]) || 0;
                return { type: 'R', params: [w, h], rotation: rot };
            }
        }

        // Fallback: if params look like width/height, use rectangle
        if (params.length >= 2 && params[0] > 0 && params[1] > 0) {
            const rot = params[2] || 0;
            return { type: 'R', params: [params[0], params[1]], rotation: rot };
        }

        return { type: 'C', params: [params[0] || 0.5], rotation: 0 };
    }

    arcToPoints(x1, y1, x2, y2, i, j, cw) {
        const cx = x1 + i, cy = y1 + j;
        const r = Math.sqrt(i * i + j * j);
        if (r < 0.0001) return [{ x: x2, y: y2 }];

        let a1 = Math.atan2(y1 - cy, x1 - cx);
        let a2 = Math.atan2(y2 - cy, x2 - cx);

        if (Math.abs(x1 - x2) < 0.01 && Math.abs(y1 - y2) < 0.01) {
            a2 = cw ? a1 - Math.PI * 2 : a1 + Math.PI * 2;
        } else {
            if (cw && a2 >= a1) a2 -= Math.PI * 2;
            if (!cw && a2 <= a1) a2 += Math.PI * 2;
        }

        const pts = [];
        const steps = Math.max(72, Math.ceil(Math.abs(a2 - a1) * r / 0.1));
        for (let n = 1; n <= steps; n++) {
            const a = a1 + (a2 - a1) * n / steps;
            pts.push({ x: cx + r * Math.cos(a), y: cy + r * Math.sin(a) });
        }
        return pts;
    }

    parseDrill(name, text, info) {
        const tools = {};
        let curTool = null;
        let unit = 'mm';
        let formatInt = 3, formatDec = 3;
        const cmds = [];
        let inHeader = true;

        const lines = text.split(/\r?\n/);

        for (const line of lines) {
            const l = line.trim();
            if (!l || l.startsWith(';')) continue;

            if (l === '%' || l === 'M95') { inHeader = false; continue; }
            if (l === 'M30' || l === 'M00') break;

            // Format from comment
            let m = l.match(/FILE_FORMAT=(\d):(\d)/i);
            if (m) { formatInt = +m[1]; formatDec = +m[2]; continue; }

            // Unit/format line
            m = l.match(/^(METRIC|INCH),?(LZ|TZ)?,?(\d+\.?\d*)?/i);
            if (m) {
                unit = m[1].toUpperCase() === 'INCH' ? 'in' : 'mm';
                if (m[3] && m[3].includes('.')) {
                    const parts = m[3].split('.');
                    formatInt = parts[0].length;
                    formatDec = parts[1].length;
                }
                continue;
            }

            // Tool definition
            m = l.match(/T(\d+)C([\d.]+)/i);
            if (m) {
                let dia = parseFloat(m[2]);
                if (unit === 'in') dia *= 25.4;
                tools[m[1]] = dia;
                tools[parseInt(m[1]).toString()] = dia;
                continue;
            }

            // Tool select
            m = l.match(/^T(\d+)$/i);
            if (m) {
                curTool = m[1];
                if (!tools[curTool]) curTool = parseInt(curTool).toString();
                continue;
            }

            if (inHeader) continue;

            // Slot
            m = line.match(/X([+-]?\d+)Y([+-]?\d+)G85X([+-]?\d+)Y([+-]?\d+)/i);
            if (m && curTool) {
                const div = Math.pow(10, formatDec);
                let x1 = parseInt(m[1]) / div;
                let y1 = parseInt(m[2]) / div;
                let x2 = parseInt(m[3]) / div;
                let y2 = parseInt(m[4]) / div;
                if (unit === 'in') { x1 *= 25.4; y1 *= 25.4; x2 *= 25.4; y2 *= 25.4; }
                cmds.push({ type: 'slot', x1, y1, x2, y2, diameter: tools[curTool] || 0.8 });
                continue;
            }

            // Drill
            m = line.match(/^X([+-]?\d+)Y([+-]?\d+)$/i);
            if (m && curTool) {
                const div = Math.pow(10, formatDec);
                let dx = parseInt(m[1]) / div;
                let dy = parseInt(m[2]) / div;
                if (unit === 'in') { dx *= 25.4; dy *= 25.4; }
                cmds.push({ type: 'drill', x: dx, y: dy, diameter: tools[curTool] || 0.8 });
            }
        }

        console.log(`[${name}] Drill: ${formatInt}.${formatDec}, Unit: ${unit}, Tools: ${Object.keys(tools).length}, Holes: ${cmds.length}`);
        return { name, ...info, cmds, visible: true };
    }

    extractBoardOutline() {
        const ol = this.layers.find(l => l.type === 'outline');
        if (!ol) { this.boardOutline = null; return; }

        const segments = [];
        for (const cmd of ol.cmds) {
            if (cmd.type === 'line') {
                segments.push({ x1: cmd.x1, y1: cmd.y1, x2: cmd.x2, y2: cmd.y2, used: false });
            } else if (cmd.type === 'arc') {
                const pts = this.arcToPoints(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.i, cmd.j, cmd.cw);
                let px = cmd.x1, py = cmd.y1;
                for (const p of pts) {
                    segments.push({ x1: px, y1: py, x2: p.x, y2: p.y, used: false });
                    px = p.x; py = p.y;
                }
            } else if (cmd.type === 'region' && cmd.points.length >= 3) {
                for (let i = 0; i < cmd.points.length - 1; i++) {
                    segments.push({ x1: cmd.points[i].x, y1: cmd.points[i].y, x2: cmd.points[i+1].x, y2: cmd.points[i+1].y, used: false });
                }
            }
        }

        if (!segments.length) { this.boardOutline = null; return; }

        const dist = (x1, y1, x2, y2) => Math.hypot(x2 - x1, y2 - y1);

        let current = segments[0];
        current.used = true;
        const path = [{ x: current.x1, y: current.y1 }, { x: current.x2, y: current.y2 }];
        let endX = current.x2, endY = current.y2;

        for (let iter = 0; iter < segments.length * 2; iter++) {
            let best = null, bestDist = Infinity, reversed = false;
            for (const seg of segments) {
                if (seg.used) continue;
                const d1 = dist(endX, endY, seg.x1, seg.y1);
                const d2 = dist(endX, endY, seg.x2, seg.y2);
                if (d1 < bestDist) { bestDist = d1; best = seg; reversed = false; }
                if (d2 < bestDist) { bestDist = d2; best = seg; reversed = true; }
            }
            if (!best || bestDist > 2) break;
            best.used = true;
            path.push({ x: reversed ? best.x1 : best.x2, y: reversed ? best.y1 : best.y2 });
            endX = reversed ? best.x1 : best.x2;
            endY = reversed ? best.y1 : best.y2;
        }

        this.boardOutline = path;
    }

    calcBounds() {
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        for (const l of this.layers) {
            for (const c of l.cmds) {
                const pts = c.points || (c.x !== undefined ? [{ x: c.x, y: c.y }] : [{ x: c.x1, y: c.y1 }, { x: c.x2, y: c.y2 }]);
                for (const p of pts) {
                    if (p.x < minX) minX = p.x;
                    if (p.y < minY) minY = p.y;
                    if (p.x > maxX) maxX = p.x;
                    if (p.y > maxY) maxY = p.y;
                }
            }
        }
        if (minX !== Infinity) this.bounds = { minX, minY, maxX, maxY };
    }

    extractNets() {
        this.nets = [];
        const netMap = new Map();

        for (const pad of this.pads) {
            if (pad.net) {
                if (!netMap.has(pad.net)) {
                    netMap.set(pad.net, []);
                }
                netMap.get(pad.net).push(pad);
            }
        }

        for (const [name, pads] of netMap) {
            this.nets.push({ name, pads });
        }

        // Also extract nets from traces
        for (const layer of this.layers) {
            if (layer.type === 'copper' || layer.type === 'inner') {
                for (const cmd of layer.cmds) {
                    if (cmd.net && !netMap.has(cmd.net)) {
                        netMap.set(cmd.net, []);
                        this.nets.push({ name: cmd.net, pads: [] });
                    }
                }
            }
        }
    }

    updateNetlistPanel() {
        const body = document.getElementById('netlistBody');
        if (!this.nets.length) {
            body.innerHTML = '<div style="padding:20px;color:var(--text2);text-align:center">Nessuna net trovata.<br>Carica file Gerber X2 per visualizzare le net.</div>';
            return;
        }

        body.innerHTML = this.nets.map(net => `
            <div class="net-item">
                <div class="net-name">${net.name}</div>
                <div class="net-pads">${net.pads.length} pad${net.pads.length !== 1 ? 's' : ''}</div>
            </div>
        `).join('');
    }

    runDRC() {
        this.drcResults = [];
        let errors = 0, warnings = 0, ok = 0;

        // Check minimum trace width
        const minTraceWidth = 0.15; // 6 mil
        for (const layer of this.layers) {
            if (layer.type === 'copper' || layer.type === 'inner') {
                for (const cmd of layer.cmds) {
                    if (cmd.type === 'line' && cmd.width < minTraceWidth) {
                        this.drcResults.push({
                            type: 'error',
                            title: 'Traccia troppo sottile',
                            desc: `Larghezza ${cmd.width.toFixed(3)}mm < ${minTraceWidth}mm su ${layer.name}`
                        });
                        errors++;
                    }
                }
            }
        }

        // Check drill sizes
        const minDrill = 0.2;
        const maxDrill = 6.0;
        for (const layer of this.layers) {
            if (layer.type === 'drill') {
                for (const cmd of layer.cmds) {
                    if (cmd.diameter < minDrill) {
                        this.drcResults.push({
                            type: 'error',
                            title: 'Foro troppo piccolo',
                            desc: `Diametro ${cmd.diameter.toFixed(3)}mm < ${minDrill}mm`
                        });
                        errors++;
                    }
                    if (cmd.diameter > maxDrill) {
                        this.drcResults.push({
                            type: 'warning',
                            title: 'Foro molto grande',
                            desc: `Diametro ${cmd.diameter.toFixed(3)}mm > ${maxDrill}mm`
                        });
                        warnings++;
                    }
                }
            }
        }

        // Check for missing layers
        const hasTop = this.layers.some(l => l.type === 'copper' && l.side === 'top');
        const hasBottom = this.layers.some(l => l.type === 'copper' && l.side === 'bottom');
        const hasOutline = this.layers.some(l => l.type === 'outline');
        const hasDrill = this.layers.some(l => l.type === 'drill');

        if (!hasOutline) {
            this.drcResults.push({
                type: 'warning',
                title: 'Outline mancante',
                desc: 'Nessun layer outline/board edge trovato'
            });
            warnings++;
        }

        if (!hasDrill && (hasTop || hasBottom)) {
            this.drcResults.push({
                type: 'info',
                title: 'Drill mancante',
                desc: 'Nessun file drill trovato'
            });
        }

        // Check board size
        if (this.bounds) {
            const w = this.bounds.maxX - this.bounds.minX;
            const h = this.bounds.maxY - this.bounds.minY;
            if (w > 500 || h > 500) {
                this.drcResults.push({
                    type: 'warning',
                    title: 'Scheda molto grande',
                    desc: `Dimensioni ${w.toFixed(1)} x ${h.toFixed(1)} mm`
                });
                warnings++;
            }
        }

        // Count OK checks
        ok = 5 - errors - warnings;
        if (ok < 0) ok = 0;

        // Update UI
        document.getElementById('drcErrors').textContent = errors;
        document.getElementById('drcWarnings').textContent = warnings;
        document.getElementById('drcOk').textContent = ok;

        const resultsDiv = document.getElementById('drcResults');
        if (!this.drcResults.length) {
            resultsDiv.innerHTML = '<div style="padding:16px;text-align:center;color:var(--accent)">&#10003; Nessun problema trovato</div>';
        } else {
            resultsDiv.innerHTML = this.drcResults.map(r => `
                <div class="drc-item ${r.type}">
                    <div class="drc-item-title">${r.title}</div>
                    <div class="drc-item-desc">${r.desc}</div>
                </div>
            `).join('');
        }
    }

    updateStats() {
        if (!this.bounds) {
            document.getElementById('statSize').textContent = '-';
            document.getElementById('statHoles').textContent = '-';
            document.getElementById('statLayers').textContent = '-';
            document.getElementById('statNets').textContent = '-';
            return;
        }

        const w = (this.bounds.maxX - this.bounds.minX).toFixed(1);
        const h = (this.bounds.maxY - this.bounds.minY).toFixed(1);
        document.getElementById('statSize').textContent = `${w} x ${h}`;

        // Count copper layers
        const copperLayers = this.layers.filter(l => l.type === 'copper' || l.type === 'inner').length;
        document.getElementById('statLayers').textContent = copperLayers || '-';

        // Count nets
        document.getElementById('statNets').textContent = this.nets.length || '-';

        const drillLayers = this.layers.filter(l => l.type === 'drill');
        if (drillLayers.length) {
            let totalDrills = 0, totalSlots = 0;
            const toolStats = {};

            for (const dl of drillLayers) {
                for (const c of dl.cmds) {
                    if (c.type === 'drill') {
                        totalDrills++;
                        const d = c.diameter.toFixed(2);
                        toolStats[d] = (toolStats[d] || 0) + 1;
                    } else if (c.type === 'slot') {
                        totalSlots++;
                    }
                }
            }

            document.getElementById('statHoles').textContent = totalDrills + (totalSlots ? ` + ${totalSlots}` : '');

            const tbody = document.querySelector('#drillTable tbody');
            tbody.innerHTML = Object.entries(toolStats)
                .sort((a, b) => parseFloat(a[0]) - parseFloat(b[0]))
                .map(([d, n], i) => `<tr><td>T${i+1}</td><td>${d}</td><td>${n}</td></tr>`)
                .join('');
            document.getElementById('drillTable').style.display = Object.keys(toolStats).length ? '' : 'none';
        } else {
            document.getElementById('statHoles').textContent = '-';
            document.getElementById('drillTable').style.display = 'none';
        }
    }

    fit() {
        if (!this.bounds) return;
        const rect = document.getElementById('canvasContainer').getBoundingClientRect();
        this.canvas2d.width = rect.width;
        this.canvas2d.height = rect.height;

        const bw = this.bounds.maxX - this.bounds.minX;
        const bh = this.bounds.maxY - this.bounds.minY;
        const sw = (rect.width - 80) / bw;
        const sh = (rect.height - 80) / bh;
        this.ppm = Math.min(sw, sh);
        this.zoom = 1;
        this.pan = { x: (rect.width - bw * this.ppm) / 2, y: (rect.height - bh * this.ppm) / 2 };
        this.updateZoomDisplay();
        this.render();
    }

    setZoom(z) {
        const old = this.zoom;
        this.zoom = Math.max(0.05, Math.min(50, z));
        const cx = this.canvas2d.width / 2, cy = this.canvas2d.height / 2;
        const s = this.zoom / old;
        this.pan.x = cx - (cx - this.pan.x) * s;
        this.pan.y = cy - (cy - this.pan.y) * s;
        this.updateZoomDisplay();
        this.render();
    }

    updateZoomDisplay() {
        document.getElementById('zoomDisplay').textContent = Math.round(this.zoom * 100) + '%';
    }

    setAllLayersVisible(v) {
        this.layers.forEach(l => l.visible = v);
        this.updateLayerList();
        this.render();
    }

    render() {
        if (!this.bounds || !this.layers.length) return;

        const ctx = this.ctx;
        const scale = this.ppm * this.zoom;
        const bw = this.bounds.maxX - this.bounds.minX;
        const bh = this.bounds.maxY - this.bounds.minY;

        ctx.fillStyle = this.colors.bg;
        ctx.fillRect(0, 0, this.canvas2d.width, this.canvas2d.height);

        ctx.save();
        ctx.translate(this.pan.x, this.pan.y);
        ctx.scale(scale, scale);

        // Apply rotation and flip
        const cx = bw / 2, cy = bh / 2;
        ctx.translate(cx, cy);

        // Flip Y to match Gerber coordinate system (Y grows up)
        ctx.scale(1, -1);

        if (this.rotation) ctx.rotate(-this.rotation * Math.PI / 180);
        if (this.flipH) ctx.scale(-1, 1);
        if (this.flipV) ctx.scale(1, -1);
        ctx.translate(-cx, -cy);
        ctx.translate(-this.bounds.minX, -this.bounds.minY);

        // Clip to board outline and fill FR4
        if (this.boardOutline?.length >= 3) {
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(this.boardOutline[0].x, this.boardOutline[0].y);
            for (let i = 1; i < this.boardOutline.length; i++) {
                ctx.lineTo(this.boardOutline[i].x, this.boardOutline[i].y);
            }
            ctx.closePath();
            ctx.clip();
            ctx.fillStyle = this.colors.fr4;
            ctx.fill();
        }

        const sorted = [...this.layers].sort((a, b) => a.order - b.order);

        if (this.copperOnly) {
            for (const l of sorted) {
                if (l.visible && (l.type === 'copper' || l.type === 'inner')) this.renderLayer(l, ctx);
            }
        } else {
            // 1. Inner layers (if visible)
            for (const l of sorted) {
                if (l.visible && l.type === 'inner') this.renderLayer(l, ctx);
            }

            // 2. Copper
            for (const l of sorted) {
                if (l.visible && l.type === 'copper') this.renderLayer(l, ctx);
            }

            // 3. Solder mask
            for (const l of sorted) {
                if (l.visible && l.type === 'mask') {
                    ctx.globalAlpha = 0.78;
                    this.renderSolderMask(l, ctx);
                    ctx.globalAlpha = 1;
                }
            }

            // 4. Silkscreen
            for (const l of sorted) {
                if (l.visible && l.type === 'silk') this.renderLayer(l, ctx);
            }
        }

        // 5. Drills
        for (const l of sorted) {
            if (l.visible && l.type === 'drill') this.renderDrillLayer(l, ctx);
        }

        if (this.boardOutline) ctx.restore();

        // Outline stroke
        const ol = this.layers.find(l => l.type === 'outline');
        if (ol?.visible && this.boardOutline) {
            ctx.strokeStyle = '#facc15';
            ctx.lineWidth = 0.15;
            ctx.beginPath();
            ctx.moveTo(this.boardOutline[0].x, this.boardOutline[0].y);
            for (let i = 1; i < this.boardOutline.length; i++) {
                ctx.lineTo(this.boardOutline[i].x, this.boardOutline[i].y);
            }
            ctx.closePath();
            ctx.stroke();
        }

        ctx.restore();

        // Draw measurement line
        if (this.measuring && this.measureStart) {
            const end = this.measureEnd || this.measureStart;
            ctx.save();
            ctx.strokeStyle = '#22c55e';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);

            // Convert world to screen coordinates
            const startScreen = this.worldToScreen(this.measureStart.x, this.measureStart.y);
            const endScreen = this.worldToScreen(end.x, end.y);

            ctx.beginPath();
            ctx.moveTo(startScreen.x, startScreen.y);
            ctx.lineTo(endScreen.x, endScreen.y);
            ctx.stroke();

            // Draw endpoints
            ctx.fillStyle = '#22c55e';
            ctx.beginPath();
            ctx.arc(startScreen.x, startScreen.y, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(endScreen.x, endScreen.y, 5, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }
    }

    worldToScreen(wx, wy) {
        const scale = this.ppm * this.zoom;
        const bw = this.bounds.maxX - this.bounds.minX;
        const bh = this.bounds.maxY - this.bounds.minY;

        let x = wx - this.bounds.minX;
        let y = wy - this.bounds.minY;

        // Apply transformations in reverse
        const cx = bw / 2, cy = bh / 2;
        x -= cx;
        y -= cy;

        // Y flip
        y = -y;

        x += cx;
        y += cy;

        return {
            x: this.pan.x + x * scale,
            y: this.pan.y + y * scale
        };
    }

    renderSolderMask(layer, ctx) {
        ctx.save();

        // Fill board with mask color
        if (this.boardOutline?.length >= 3) {
            ctx.fillStyle = layer.color;
            ctx.beginPath();
            ctx.moveTo(this.boardOutline[0].x, this.boardOutline[0].y);
            for (let i = 1; i < this.boardOutline.length; i++) {
                ctx.lineTo(this.boardOutline[i].x, this.boardOutline[i].y);
            }
            ctx.closePath();
            ctx.fill();
        }

        // Cut out all dark features (pad openings)
        ctx.globalCompositeOperation = 'destination-out';
        ctx.fillStyle = '#000';
        ctx.strokeStyle = '#000';

        for (const cmd of layer.cmds) {
            if (cmd.polarity === 'clear') continue;

            if (cmd.type === 'region' && cmd.points.length >= 3) {
                ctx.beginPath();
                ctx.moveTo(cmd.points[0].x, cmd.points[0].y);
                for (let i = 1; i < cmd.points.length; i++) {
                    ctx.lineTo(cmd.points[i].x, cmd.points[i].y);
                }
                ctx.closePath();
                ctx.fill();
            } else if (cmd.type === 'line') {
                ctx.lineWidth = cmd.width || 0.1;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(cmd.x1, cmd.y1);
                ctx.lineTo(cmd.x2, cmd.y2);
                ctx.stroke();
            } else if (cmd.type === 'flash') {
                this.drawFlash(ctx, cmd.x, cmd.y, cmd.aperture);
            }
        }

        ctx.restore();
    }

    renderLayer(layer, ctx) {
        for (const cmd of layer.cmds) {
            ctx.fillStyle = layer.color;
            ctx.strokeStyle = layer.color;
            ctx.globalCompositeOperation = cmd.polarity === 'clear' ? 'destination-out' : 'source-over';

            if (cmd.type === 'region' && cmd.points.length >= 3) {
                ctx.beginPath();
                ctx.moveTo(cmd.points[0].x, cmd.points[0].y);
                for (let i = 1; i < cmd.points.length; i++) {
                    ctx.lineTo(cmd.points[i].x, cmd.points[i].y);
                }
                ctx.closePath();
                ctx.fill();
            } else if (cmd.type === 'line') {
                ctx.lineWidth = cmd.width || 0.1;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(cmd.x1, cmd.y1);
                ctx.lineTo(cmd.x2, cmd.y2);
                ctx.stroke();
            } else if (cmd.type === 'arc') {
                ctx.lineWidth = cmd.width || 0.1;
                ctx.lineCap = 'round';
                const pts = this.arcToPoints(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.i, cmd.j, cmd.cw);
                ctx.beginPath();
                ctx.moveTo(cmd.x1, cmd.y1);
                for (const p of pts) ctx.lineTo(p.x, p.y);
                ctx.stroke();
            } else if (cmd.type === 'flash') {
                this.drawFlash(ctx, cmd.x, cmd.y, cmd.aperture);
            }
        }
        ctx.globalCompositeOperation = 'source-over';
    }

    renderDrillLayer(layer, ctx) {
        for (const cmd of layer.cmds) {
            if (cmd.type === 'drill') {
                ctx.globalCompositeOperation = 'source-over';
                ctx.fillStyle = this.colors.bg;
                ctx.beginPath();
                ctx.arc(cmd.x, cmd.y, cmd.diameter / 2, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = this.colors.copper;
                ctx.lineWidth = 0.15;
                ctx.beginPath();
                ctx.arc(cmd.x, cmd.y, cmd.diameter / 2 + 0.15, 0, Math.PI * 2);
                ctx.stroke();
            } else if (cmd.type === 'slot') {
                ctx.globalCompositeOperation = 'source-over';
                ctx.strokeStyle = this.colors.copper;
                ctx.lineCap = 'round';
                ctx.lineWidth = cmd.diameter + 0.3;
                ctx.beginPath();
                ctx.moveTo(cmd.x1, cmd.y1);
                ctx.lineTo(cmd.x2, cmd.y2);
                ctx.stroke();

                ctx.strokeStyle = this.colors.bg;
                ctx.lineWidth = cmd.diameter;
                ctx.beginPath();
                ctx.moveTo(cmd.x1, cmd.y1);
                ctx.lineTo(cmd.x2, cmd.y2);
                ctx.stroke();
            }
        }
    }

    drawFlash(ctx, x, y, ap) {
        const t = ap.type;
        const p = ap.params;
        const rot = (ap.rotation || 0) * Math.PI / 180;

        ctx.save();
        ctx.translate(x, y);
        if (rot) ctx.rotate(rot);

        if (t === 'C') {
            ctx.beginPath();
            ctx.arc(0, 0, (p[0] || 0.5) / 2, 0, Math.PI * 2);
            ctx.fill();
        } else if (t === 'R') {
            const w = p[0] || 0.5;
            const h = p.length > 1 ? p[1] : w;
            ctx.fillRect(-w / 2, -h / 2, w, h);
        } else if (t === 'O') {
            const w = p[0] || 0.5;
            const h = p.length > 1 ? p[1] : w;
            ctx.beginPath();
            if (Math.abs(w - h) < 0.001) {
                ctx.arc(0, 0, w / 2, 0, Math.PI * 2);
            } else if (w > h) {
                const r = h / 2, dx = (w - h) / 2;
                ctx.moveTo(-dx, -r);
                ctx.lineTo(dx, -r);
                ctx.arc(dx, 0, r, -Math.PI / 2, Math.PI / 2);
                ctx.lineTo(-dx, r);
                ctx.arc(-dx, 0, r, Math.PI / 2, -Math.PI / 2);
            } else {
                const r = w / 2, dy = (h - w) / 2;
                ctx.moveTo(r, -dy);
                ctx.lineTo(r, dy);
                ctx.arc(0, dy, r, 0, Math.PI);
                ctx.lineTo(-r, -dy);
                ctx.arc(0, -dy, r, Math.PI, 0);
            }
            ctx.closePath();
            ctx.fill();
        } else if (t === 'P') {
            const od = p[0] || 0.5;
            const vertices = p[1] || 4;
            const pRot = (p[2] || 0) * Math.PI / 180;
            ctx.beginPath();
            for (let i = 0; i < vertices; i++) {
                const angle = pRot + (i * 2 * Math.PI / vertices);
                const px = (od / 2) * Math.cos(angle);
                const py = (od / 2) * Math.sin(angle);
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fill();
        } else if (t === 'POLY' && ap.vertices) {
            ctx.beginPath();
            ctx.moveTo(ap.vertices[0].x, ap.vertices[0].y);
            for (let i = 1; i < ap.vertices.length; i++) {
                ctx.lineTo(ap.vertices[i].x, ap.vertices[i].y);
            }
            ctx.closePath();
            ctx.fill();
        } else {
            // Fallback
            ctx.beginPath();
            ctx.arc(0, 0, (p[0] || 0.5) / 2, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.restore();
    }

    // 3D Rendering
    init3D() {
        if (this.renderer) return;

        const container = document.getElementById('canvas3d');
        const rect = container.getBoundingClientRect();

        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x0c0c0c);

        this.camera = new THREE.PerspectiveCamera(45, rect.width / rect.height, 0.1, 1000);
        this.camera.position.set(0, -100, 80);

        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.renderer.setSize(rect.width, rect.height);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(this.renderer.domElement);

        this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
        // Disable damping to avoid flywheel effect
        this.controls.enableDamping = false;
        this.controls.rotateSpeed = 0.8;
        this.controls.zoomSpeed = 1.0;
        this.controls.panSpeed = 0.8;

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        this.scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 50, 100);
        this.scene.add(directionalLight);

        const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight2.position.set(-50, -50, 50);
        this.scene.add(directionalLight2);
    }

    resize3D() {
        if (!this.renderer) return;
        const container = document.getElementById('canvas3d');
        const rect = container.getBoundingClientRect();
        this.camera.aspect = rect.width / rect.height;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(rect.width, rect.height);
    }

    update3D() {
        if (!this.bounds || !this.scene) return;

        // Remove old PCB mesh
        if (this.pcbMesh) {
            this.scene.remove(this.pcbMesh);
            this.pcbMesh.traverse(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(m => m.dispose());
                    } else {
                        child.material.dispose();
                    }
                }
            });
        }

        this.pcbMesh = new THREE.Group();

        const bw = this.bounds.maxX - this.bounds.minX;
        const bh = this.bounds.maxY - this.bounds.minY;
        const cx = (this.bounds.minX + this.bounds.maxX) / 2;
        const cy = (this.bounds.minY + this.bounds.maxY) / 2;

        // PCB thickness
        const pcbThickness = 1.6;
        const copperThickness = 0.035;
        const maskThickness = 0.02;
        const silkThickness = 0.01;

        // FR4 base board
        let boardShape;
        if (this.boardOutline?.length >= 3) {
            boardShape = new THREE.Shape();
            boardShape.moveTo(this.boardOutline[0].x - cx, this.boardOutline[0].y - cy);
            for (let i = 1; i < this.boardOutline.length; i++) {
                boardShape.lineTo(this.boardOutline[i].x - cx, this.boardOutline[i].y - cy);
            }
            boardShape.closePath();
        } else {
            boardShape = new THREE.Shape();
            boardShape.moveTo(-bw/2, -bh/2);
            boardShape.lineTo(bw/2, -bh/2);
            boardShape.lineTo(bw/2, bh/2);
            boardShape.lineTo(-bw/2, bh/2);
            boardShape.closePath();
        }

        // FR4 material - always show
        const fr4Geometry = new THREE.ExtrudeGeometry(boardShape, {
            depth: pcbThickness,
            bevelEnabled: false
        });
        const fr4Material = new THREE.MeshPhongMaterial({ color: 0xc19a6b });
        const fr4Mesh = new THREE.Mesh(fr4Geometry, fr4Material);
        fr4Mesh.position.z = -pcbThickness / 2;
        this.pcbMesh.add(fr4Mesh);

        // Add layers based on filters
        const sorted = [...this.layers].sort((a, b) => a.order - b.order);

        // Copper only mode - only render copper and inner layers
        if (this.copperOnly) {
            for (const layer of sorted) {
                if (!layer.visible) continue;
                if (layer.type === 'copper') {
                    const zPos = layer.side === 'top' ? pcbThickness / 2 : -pcbThickness / 2 - copperThickness;
                    this.addLayer3D(layer, cx, cy, zPos, copperThickness, 0xb45309);
                } else if (layer.type === 'inner') {
                    const innerZ = (layer.order - 10) * 0.3 - pcbThickness / 4;
                    this.addLayer3D(layer, cx, cy, innerZ, copperThickness, 0xcd7f32);
                }
            }
        } else {
            // Full rendering with all visible layers
            // 1. Inner layers
            for (const layer of sorted) {
                if (!layer.visible || layer.type !== 'inner') continue;
                const innerZ = (layer.order - 10) * 0.3 - pcbThickness / 4;
                this.addLayer3D(layer, cx, cy, innerZ, copperThickness, 0xcd7f32);
            }

            // 2. Copper layers
            for (const layer of sorted) {
                if (!layer.visible || layer.type !== 'copper') continue;
                const zPos = layer.side === 'top' ? pcbThickness / 2 : -pcbThickness / 2 - copperThickness;
                this.addLayer3D(layer, cx, cy, zPos, copperThickness, 0xb45309);
            }

            // 3. Solder mask
            for (const layer of sorted) {
                if (!layer.visible || layer.type !== 'mask') continue;
                const zPos = layer.side === 'top' ? pcbThickness / 2 + copperThickness : -pcbThickness / 2 - copperThickness - maskThickness;
                const maskColor = new THREE.Color(this.colors.mask);
                this.addMaskLayer3D(layer, cx, cy, zPos, maskThickness, maskColor.getHex(), boardShape);
            }

            // 4. Silkscreen
            for (const layer of sorted) {
                if (!layer.visible || layer.type !== 'silk') continue;
                const zPos = layer.side === 'top' ? pcbThickness / 2 + copperThickness + maskThickness : -pcbThickness / 2 - copperThickness - maskThickness - silkThickness;
                const silkColor = new THREE.Color(this.colors.silk);
                this.addLayer3D(layer, cx, cy, zPos, silkThickness, silkColor.getHex());
            }
        }

        // Add drill holes (always visible if drill layer is visible)
        for (const layer of this.layers) {
            if (layer.type === 'drill' && layer.visible) {
                for (const cmd of layer.cmds) {
                    if (cmd.type === 'drill') {
                        const holeGeometry = new THREE.CylinderGeometry(cmd.diameter / 2, cmd.diameter / 2, pcbThickness + 1, 24);
                        const holeMaterial = new THREE.MeshPhongMaterial({ color: 0x222222 });
                        const holeMesh = new THREE.Mesh(holeGeometry, holeMaterial);
                        holeMesh.position.set(cmd.x - cx, cmd.y - cy, 0);
                        holeMesh.rotation.x = Math.PI / 2;
                        this.pcbMesh.add(holeMesh);
                    } else if (cmd.type === 'slot') {
                        // Render slot as capsule shape
                        const dx = cmd.x2 - cmd.x1;
                        const dy = cmd.y2 - cmd.y1;
                        const length = Math.sqrt(dx * dx + dy * dy);
                        const angle = Math.atan2(dy, dx);

                        const slotGeometry = new THREE.CylinderGeometry(cmd.diameter / 2, cmd.diameter / 2, pcbThickness + 1, 16);
                        const slotMaterial = new THREE.MeshPhongMaterial({ color: 0x222222 });

                        // Start cap
                        const cap1 = new THREE.Mesh(slotGeometry, slotMaterial);
                        cap1.position.set(cmd.x1 - cx, cmd.y1 - cy, 0);
                        cap1.rotation.x = Math.PI / 2;
                        this.pcbMesh.add(cap1);

                        // End cap
                        const cap2 = new THREE.Mesh(slotGeometry.clone(), slotMaterial);
                        cap2.position.set(cmd.x2 - cx, cmd.y2 - cy, 0);
                        cap2.rotation.x = Math.PI / 2;
                        this.pcbMesh.add(cap2);

                        // Connecting box
                        if (length > 0.01) {
                            const boxGeometry = new THREE.BoxGeometry(length, cmd.diameter, pcbThickness + 1);
                            const boxMesh = new THREE.Mesh(boxGeometry, slotMaterial);
                            boxMesh.position.set((cmd.x1 + cmd.x2) / 2 - cx, (cmd.y1 + cmd.y2) / 2 - cy, 0);
                            boxMesh.rotation.z = angle;
                            this.pcbMesh.add(boxMesh);
                        }
                    }
                }
            }
        }

        this.scene.add(this.pcbMesh);

        // Center camera
        const maxDim = Math.max(bw, bh);
        this.camera.position.set(0, -maxDim * 1.2, maxDim * 0.8);
        this.controls.target.set(0, 0, 0);
        this.controls.update();
    }

    addLayer3D(layer, cx, cy, zPos, thickness, color) {
        const material = new THREE.MeshPhongMaterial({ color, side: THREE.DoubleSide });

        for (const cmd of layer.cmds) {
            if (cmd.polarity === 'clear') continue;

            if (cmd.type === 'region' && cmd.points.length >= 3) {
                try {
                    const shape = new THREE.Shape();
                    shape.moveTo(cmd.points[0].x - cx, cmd.points[0].y - cy);
                    for (let i = 1; i < cmd.points.length; i++) {
                        shape.lineTo(cmd.points[i].x - cx, cmd.points[i].y - cy);
                    }
                    shape.closePath();

                    const geometry = new THREE.ExtrudeGeometry(shape, { depth: thickness, bevelEnabled: false });
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.z = zPos;
                    this.pcbMesh.add(mesh);
                } catch (e) {
                    // Skip invalid shapes
                }
            } else if (cmd.type === 'flash') {
                this.addFlash3D(cmd, cx, cy, zPos, thickness, material);
            } else if (cmd.type === 'line') {
                this.addLine3D(cmd, cx, cy, zPos, thickness, material);
            } else if (cmd.type === 'arc') {
                this.addArc3D(cmd, cx, cy, zPos, thickness, material);
            }
        }
    }

    addFlash3D(cmd, cx, cy, zPos, thickness, material) {
        const ap = cmd.aperture;
        const x = cmd.x - cx;
        const y = cmd.y - cy;
        let mesh;

        if (ap.type === 'C') {
            // Circle
            const radius = (ap.params[0] || 0.5) / 2;
            const geometry = new THREE.CylinderGeometry(radius, radius, thickness, 24);
            mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, zPos + thickness / 2);
            mesh.rotation.x = Math.PI / 2;
        } else if (ap.type === 'R') {
            // Rectangle
            const w = ap.params[0] || 0.5;
            const h = ap.params.length > 1 ? ap.params[1] : w;
            const geometry = new THREE.BoxGeometry(w, h, thickness);
            mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, zPos + thickness / 2);
            if (ap.rotation) mesh.rotation.z = ap.rotation * Math.PI / 180;
        } else if (ap.type === 'O') {
            // Obround - create as rounded rectangle using shape
            const w = ap.params[0] || 0.5;
            const h = ap.params.length > 1 ? ap.params[1] : w;
            const r = Math.min(w, h) / 2;

            const shape = new THREE.Shape();
            if (w > h) {
                const dx = (w - h) / 2;
                shape.moveTo(-dx, -r);
                shape.lineTo(dx, -r);
                shape.absarc(dx, 0, r, -Math.PI/2, Math.PI/2, false);
                shape.lineTo(-dx, r);
                shape.absarc(-dx, 0, r, Math.PI/2, -Math.PI/2, false);
            } else {
                const dy = (h - w) / 2;
                shape.moveTo(r, -dy);
                shape.lineTo(r, dy);
                shape.absarc(0, dy, r, 0, Math.PI, false);
                shape.lineTo(-r, -dy);
                shape.absarc(0, -dy, r, Math.PI, 0, false);
            }
            shape.closePath();

            const geometry = new THREE.ExtrudeGeometry(shape, { depth: thickness, bevelEnabled: false });
            mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, zPos);
            if (ap.rotation) mesh.rotation.z = ap.rotation * Math.PI / 180;
        } else if (ap.type === 'P') {
            // Polygon
            const od = ap.params[0] || 0.5;
            const vertices = ap.params[1] || 4;
            const pRot = (ap.params[2] || 0) * Math.PI / 180;

            const shape = new THREE.Shape();
            for (let i = 0; i < vertices; i++) {
                const angle = pRot + (i * 2 * Math.PI / vertices);
                const px = (od / 2) * Math.cos(angle);
                const py = (od / 2) * Math.sin(angle);
                if (i === 0) shape.moveTo(px, py);
                else shape.lineTo(px, py);
            }
            shape.closePath();

            const geometry = new THREE.ExtrudeGeometry(shape, { depth: thickness, bevelEnabled: false });
            mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, zPos);
        } else if (ap.type === 'POLY' && ap.vertices) {
            // Custom polygon from macro
            const shape = new THREE.Shape();
            shape.moveTo(ap.vertices[0].x, ap.vertices[0].y);
            for (let i = 1; i < ap.vertices.length; i++) {
                shape.lineTo(ap.vertices[i].x, ap.vertices[i].y);
            }
            shape.closePath();

            const geometry = new THREE.ExtrudeGeometry(shape, { depth: thickness, bevelEnabled: false });
            mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, zPos);
        } else {
            // Fallback to circle
            const geometry = new THREE.CylinderGeometry(0.25, 0.25, thickness, 16);
            mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, zPos + thickness / 2);
            mesh.rotation.x = Math.PI / 2;
        }

        if (mesh) this.pcbMesh.add(mesh);
    }

    addLine3D(cmd, cx, cy, zPos, thickness, material) {
        const dx = cmd.x2 - cmd.x1;
        const dy = cmd.y2 - cmd.y1;
        const length = Math.sqrt(dx * dx + dy * dy);
        if (length < 0.001) return;

        const angle = Math.atan2(dy, dx);
        const width = cmd.width || 0.1;

        // Create rounded line using shape for better visual
        const shape = new THREE.Shape();
        const halfW = width / 2;
        const halfL = length / 2;

        // Rounded rectangle
        shape.moveTo(-halfL, -halfW);
        shape.lineTo(halfL, -halfW);
        shape.absarc(halfL, 0, halfW, -Math.PI/2, Math.PI/2, false);
        shape.lineTo(-halfL, halfW);
        shape.absarc(-halfL, 0, halfW, Math.PI/2, -Math.PI/2, false);
        shape.closePath();

        const geometry = new THREE.ExtrudeGeometry(shape, { depth: thickness, bevelEnabled: false });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set((cmd.x1 + cmd.x2) / 2 - cx, (cmd.y1 + cmd.y2) / 2 - cy, zPos);
        mesh.rotation.z = angle;
        this.pcbMesh.add(mesh);
    }

    addArc3D(cmd, cx, cy, zPos, thickness, material) {
        // Convert arc to line segments for 3D
        const pts = this.arcToPoints(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.i, cmd.j, cmd.cw);
        let px = cmd.x1, py = cmd.y1;

        for (const p of pts) {
            const dx = p.x - px;
            const dy = p.y - py;
            const length = Math.sqrt(dx * dx + dy * dy);

            if (length > 0.001) {
                const angle = Math.atan2(dy, dx);
                const width = cmd.width || 0.1;

                const geometry = new THREE.BoxGeometry(length + width, width, thickness);
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set((px + p.x) / 2 - cx, (py + p.y) / 2 - cy, zPos + thickness / 2);
                mesh.rotation.z = angle;
                this.pcbMesh.add(mesh);
            }

            px = p.x;
            py = p.y;
        }
    }

    addMaskLayer3D(layer, cx, cy, zPos, thickness, color, boardShape) {
        const material = new THREE.MeshPhongMaterial({
            color,
            transparent: true,
            opacity: 0.78,
            side: THREE.DoubleSide
        });

        const geometry = new THREE.ExtrudeGeometry(boardShape, { depth: thickness, bevelEnabled: false });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.z = zPos;
        this.pcbMesh.add(mesh);
    }

    // SVG Export
    exportSvg() {
        if (!this.bounds || !this.layers.length) return;

        const bw = this.bounds.maxX - this.bounds.minX;
        const bh = this.bounds.maxY - this.bounds.minY;
        const padding = 5;
        const scale = 10; // 10 pixels per mm

        const svgWidth = (bw + padding * 2) * scale;
        const svgHeight = (bh + padding * 2) * scale;

        const lines = [];
        lines.push('<?xml version="1.0" encoding="UTF-8"?>');
        lines.push(`<svg xmlns="http://www.w3.org/2000/svg" width="${svgWidth}" height="${svgHeight}" viewBox="0 0 ${svgWidth} ${svgHeight}">`);
        lines.push('<defs>');
        lines.push('  <style>');
        lines.push(`    .copper { fill: ${this.colors.copper}; stroke: none; }`);
        lines.push(`    .mask { fill: ${this.colors.mask}; stroke: none; opacity: 0.78; }`);
        lines.push(`    .silk { fill: ${this.colors.silk}; stroke: none; }`);
        lines.push('    .outline { fill: none; stroke: #facc15; stroke-width: 0.15; }');
        lines.push(`    .drill { fill: ${this.colors.bg}; stroke: ${this.colors.copper}; stroke-width: 0.15; }`);
        lines.push(`    .fr4 { fill: ${this.colors.fr4}; stroke: none; }`);
        lines.push('    .inner { fill: #cd7f32; stroke: none; }');
        lines.push('  </style>');
        lines.push('</defs>');
        lines.push(`<rect width="100%" height="100%" fill="${this.colors.bg}"/>`);
        lines.push(`<g transform="translate(${padding * scale}, ${(bh + padding) * scale}) scale(${scale}, ${-scale})">`);

        // FR4 background
        if (this.boardOutline?.length >= 3) {
            const pathData = this.boardOutline.map((p, i) =>
                `${i === 0 ? 'M' : 'L'}${(p.x - this.bounds.minX).toFixed(3)},${(p.y - this.bounds.minY).toFixed(3)}`
            ).join(' ') + ' Z';
            lines.push(`  <path class="fr4" d="${pathData}"/>`);
        }

        const sorted = [...this.layers].sort((a, b) => a.order - b.order);

        for (const layer of sorted) {
            if (!layer.visible) continue;
            if (layer.type === 'outline') continue; // Outline rendered separately

            const layerClass = layer.type === 'inner' ? 'inner' : layer.type;
            const layerId = layer.name.replace(/[^a-zA-Z0-9]/g, '_');
            lines.push(`  <g class="${layerClass}" id="layer-${layerId}" fill="${layer.color}">`);

            for (const cmd of layer.cmds) {
                if (cmd.polarity === 'clear') continue;

                if (cmd.type === 'region' && cmd.points.length >= 3) {
                    const pathData = cmd.points.map((p, i) =>
                        `${i === 0 ? 'M' : 'L'}${(p.x - this.bounds.minX).toFixed(3)},${(p.y - this.bounds.minY).toFixed(3)}`
                    ).join(' ') + ' Z';
                    lines.push(`    <path d="${pathData}"/>`);
                } else if (cmd.type === 'line') {
                    const x1 = (cmd.x1 - this.bounds.minX).toFixed(3);
                    const y1 = (cmd.y1 - this.bounds.minY).toFixed(3);
                    const x2 = (cmd.x2 - this.bounds.minX).toFixed(3);
                    const y2 = (cmd.y2 - this.bounds.minY).toFixed(3);
                    const w = (cmd.width || 0.1).toFixed(3);
                    lines.push(`    <line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="${layer.color}" stroke-width="${w}" stroke-linecap="round" fill="none"/>`);
                } else if (cmd.type === 'arc') {
                    // Convert arc to polyline
                    const pts = this.arcToPoints(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.i, cmd.j, cmd.cw);
                    const pathParts = [`M${(cmd.x1 - this.bounds.minX).toFixed(3)},${(cmd.y1 - this.bounds.minY).toFixed(3)}`];
                    for (const p of pts) {
                        pathParts.push(`L${(p.x - this.bounds.minX).toFixed(3)},${(p.y - this.bounds.minY).toFixed(3)}`);
                    }
                    const w = (cmd.width || 0.1).toFixed(3);
                    lines.push(`    <path d="${pathParts.join(' ')}" stroke="${layer.color}" stroke-width="${w}" stroke-linecap="round" fill="none"/>`);
                } else if (cmd.type === 'flash') {
                    lines.push(this.flashToSvg(cmd, layer.color));
                } else if (cmd.type === 'drill') {
                    const x = (cmd.x - this.bounds.minX).toFixed(3);
                    const y = (cmd.y - this.bounds.minY).toFixed(3);
                    const r = (cmd.diameter / 2).toFixed(3);
                    lines.push(`    <circle class="drill" cx="${x}" cy="${y}" r="${r}"/>`);
                } else if (cmd.type === 'slot') {
                    const x1 = (cmd.x1 - this.bounds.minX).toFixed(3);
                    const y1 = (cmd.y1 - this.bounds.minY).toFixed(3);
                    const x2 = (cmd.x2 - this.bounds.minX).toFixed(3);
                    const y2 = (cmd.y2 - this.bounds.minY).toFixed(3);
                    const w = cmd.diameter.toFixed(3);
                    lines.push(`    <line class="drill" x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="${this.colors.bg}" stroke-width="${w}" stroke-linecap="round"/>`);
                }
            }

            lines.push('  </g>');
        }

        // Board outline
        if (this.boardOutline?.length >= 3) {
            const olLayer = this.layers.find(l => l.type === 'outline');
            if (olLayer?.visible) {
                const pathData = this.boardOutline.map((p, i) =>
                    `${i === 0 ? 'M' : 'L'}${(p.x - this.bounds.minX).toFixed(3)},${(p.y - this.bounds.minY).toFixed(3)}`
                ).join(' ') + ' Z';
                lines.push(`  <path class="outline" d="${pathData}"/>`);
            }
        }

        lines.push('</g>');
        lines.push('</svg>');

        // Download
        const svg = lines.join('\n');
        const blob = new Blob([svg], { type: 'image/svg+xml' });
        const a = document.createElement('a');
        a.download = 'pcb.svg';
        a.href = URL.createObjectURL(blob);
        a.click();
        URL.revokeObjectURL(a.href);
    }

    flashToSvg(cmd, color) {
        const x = cmd.x - this.bounds.minX;
        const y = cmd.y - this.bounds.minY;
        const ap = cmd.aperture;
        const rot = ap.rotation || 0;

        if (ap.type === 'C') {
            const r = ((ap.params[0] || 0.5) / 2).toFixed(3);
            return `    <circle cx="${x.toFixed(3)}" cy="${y.toFixed(3)}" r="${r}"/>`;
        } else if (ap.type === 'R') {
            const w = ap.params[0] || 0.5;
            const h = ap.params.length > 1 ? ap.params[1] : w;
            if (rot) {
                return `    <rect x="${(-w/2).toFixed(3)}" y="${(-h/2).toFixed(3)}" width="${w.toFixed(3)}" height="${h.toFixed(3)}" transform="translate(${x.toFixed(3)},${y.toFixed(3)}) rotate(${rot})"/>`;
            }
            return `    <rect x="${(x - w/2).toFixed(3)}" y="${(y - h/2).toFixed(3)}" width="${w.toFixed(3)}" height="${h.toFixed(3)}"/>`;
        } else if (ap.type === 'O') {
            const w = ap.params[0] || 0.5;
            const h = ap.params.length > 1 ? ap.params[1] : w;
            const r = Math.min(w, h) / 2;
            if (rot) {
                return `    <rect x="${(-w/2).toFixed(3)}" y="${(-h/2).toFixed(3)}" width="${w.toFixed(3)}" height="${h.toFixed(3)}" rx="${r.toFixed(3)}" transform="translate(${x.toFixed(3)},${y.toFixed(3)}) rotate(${rot})"/>`;
            }
            return `    <rect x="${(x - w/2).toFixed(3)}" y="${(y - h/2).toFixed(3)}" width="${w.toFixed(3)}" height="${h.toFixed(3)}" rx="${r.toFixed(3)}"/>`;
        } else if (ap.type === 'P') {
            const od = ap.params[0] || 0.5;
            const vertices = ap.params[1] || 4;
            const pRot = (ap.params[2] || 0) * Math.PI / 180;
            const pts = [];
            for (let i = 0; i < vertices; i++) {
                const angle = pRot + (i * 2 * Math.PI / vertices);
                const px = x + (od / 2) * Math.cos(angle);
                const py = y + (od / 2) * Math.sin(angle);
                pts.push(`${px.toFixed(3)},${py.toFixed(3)}`);
            }
            return `    <polygon points="${pts.join(' ')}"/>`;
        } else if (ap.type === 'POLY' && ap.vertices) {
            const pts = ap.vertices.map(v => `${(x + v.x).toFixed(3)},${(y + v.y).toFixed(3)}`);
            return `    <polygon points="${pts.join(' ')}"/>`;
        }
        // Fallback
        return `    <circle cx="${x.toFixed(3)}" cy="${y.toFixed(3)}" r="0.25"/>`;
    }

    updateUI() {
        this.updateFileList();
        this.updateLayerList();
        document.getElementById('layerCount').textContent = this.layers.length;
    }

    updateFileList() {
        document.getElementById('fileList').innerHTML = this.files.map((f, i) => {
            const l = this.layers[i];
            return `<div class="file-item"><span class="file-tag ${l.type}">${l.type.slice(0,4)}</span><span class="file-name">${f.name}</span><button class="file-del" onclick="viewer.removeFile(${i})">x</button></div>`;
        }).join('');
    }

    updateLayerList() {
        document.getElementById('layerList').innerHTML = this.layers.length ? this.layers.map((l, i) => `
            <div class="layer-item" onclick="viewer.toggleLayer(${i})">
                <div class="layer-toggle ${l.visible ? 'on' : ''}"></div>
                <div class="layer-color" style="background:${l.color}"></div>
                <span class="layer-name">${l.name}</span>
            </div>`).join('') : '<div style="color:var(--text2);text-align:center;padding:16px">Nessun layer</div>';
    }

    toggleLayer(i) {
        this.layers[i].visible = !this.layers[i].visible;
        this.updateLayerList();
        this.render();
        if (this.mode === '3d') this.update3D();
    }

    removeFile(i) {
        this.files.splice(i, 1);
        this.layers.splice(i, 1);
        this.extractBoardOutline();
        this.calcBounds();
        this.extractNets();
        this.updateUI();
        this.updateStats();
        if (!this.layers.length) {
            document.getElementById('emptyState').style.display = 'flex';
            this.canvas2d.style.display = 'none';
        } else {
            this.fit();
        }
    }

    clear() {
        this.files = [];
        this.layers = [];
        this.bounds = null;
        this.boardOutline = null;
        this.pads = [];
        this.nets = [];
        this.x2Attributes = {};
        this.updateUI();
        this.updateStats();
        document.getElementById('emptyState').style.display = 'flex';
        this.canvas2d.style.display = 'none';
        if (this.pcbMesh) {
            this.scene.remove(this.pcbMesh);
            this.pcbMesh = null;
        }
    }

    exportPng() {
        if (!this.layers.length) return;
        const a = document.createElement('a');
        a.download = 'pcb.png';
        a.href = this.canvas2d.toDataURL('image/png');
        a.click();
    }
}

const viewer = new GerberViewer();
</script>
</body>
</html>
