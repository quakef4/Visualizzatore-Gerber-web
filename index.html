<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gerber Viewer Pro v23 - 2D/3D</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        :root { --bg:#0c0c0c; --panel:#141414; --surface:#1e1e1e; --border:#2a2a2a; --text:#e0e0e0; --text2:#666; --accent:#22c55e; }
        * { margin:0; padding:0; box-sizing:border-box; }
        body { font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif; background:var(--bg); color:var(--text); height:100vh; overflow:hidden; }
        .app { display:grid; grid-template-columns:300px 1fr; grid-template-rows:50px 1fr; height:100vh; }
        header { grid-column:1/-1; background:var(--panel); border-bottom:1px solid var(--border); padding:0 20px; display:flex; align-items:center; justify-content:space-between; }
        .logo { font-weight:700; font-size:1.1rem; display:flex; align-items:center; gap:10px; }
        .logo-icon { width:32px; height:32px; background:linear-gradient(135deg,var(--accent),#16a34a); border-radius:8px; display:flex; align-items:center; justify-content:center; font-size:16px; color:#000; }
        .logo span { color:var(--accent); }
        .header-actions { display:flex; gap:8px; }
        .btn { padding:8px 16px; background:var(--surface); border:1px solid var(--border); border-radius:6px; color:var(--text); font-size:13px; cursor:pointer; transition:all .2s; }
        .btn:hover { border-color:var(--accent); color:var(--accent); }
        .sidebar { background:var(--panel); border-right:1px solid var(--border); overflow-y:auto; }
        .panel { border-bottom:1px solid var(--border); }
        .panel-header { padding:14px 16px; font-size:11px; font-weight:600; text-transform:uppercase; color:var(--accent); background:rgba(34,197,94,.08); }
        .panel-body { padding:14px 16px; }
        .dropzone { border:2px dashed var(--border); border-radius:10px; padding:24px 16px; text-align:center; cursor:pointer; transition:all .2s; }
        .dropzone:hover,.dropzone.over { border-color:var(--accent); background:rgba(34,197,94,.08); }
        .dropzone input { display:none; }
        .dropzone-icon { font-size:36px; margin-bottom:10px; }
        .dropzone-title { font-size:13px; font-weight:600; margin-bottom:4px; }
        .dropzone-subtitle { font-size:11px; color:var(--text2); }
        .file-list { max-height:100px; overflow-y:auto; margin-top:12px; }
        .file-item { display:flex; align-items:center; gap:8px; padding:8px 10px; background:var(--surface); border-radius:6px; margin-bottom:4px; font-size:11px; }
        .file-tag { font-size:9px; padding:3px 6px; border-radius:4px; font-weight:700; }
        .file-tag.copper { background:#92400e; color:#fef3c7; }
        .file-tag.mask { background:#15803d; color:#dcfce7; }
        .file-tag.silk { background:#525252; color:#fff; }
        .file-tag.drill { background:#1d4ed8; color:#dbeafe; }
        .file-tag.outline { background:#a16207; color:#fef9c3; }
        .file-name { flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
        .file-del { background:none; border:none; color:var(--text2); cursor:pointer; padding:4px 8px; border-radius:4px; }
        .file-del:hover { background:rgba(239,68,68,.2); color:#ef4444; }
        .layer-list { max-height:200px; overflow-y:auto; }
        .layer-item { display:flex; align-items:center; gap:10px; padding:10px 12px; cursor:pointer; border-radius:6px; font-size:12px; }
        .layer-item:hover { background:rgba(255,255,255,.04); }
        .layer-toggle { width:36px; height:18px; background:var(--bg); border:1px solid var(--border); border-radius:9px; position:relative; }
        .layer-toggle::after { content:''; position:absolute; top:2px; left:2px; width:12px; height:12px; background:var(--text2); border-radius:50%; transition:.2s; }
        .layer-toggle.on { background:var(--accent); border-color:var(--accent); }
        .layer-toggle.on::after { left:20px; background:#000; }
        .layer-color { width:16px; height:16px; border-radius:4px; border:1px solid rgba(255,255,255,.2); }
        .layer-name { flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
        .layer-actions { display:flex; gap:8px; margin-top:12px; }
        .layer-actions .btn { flex:1; justify-content:center; padding:8px; font-size:11px; }
        .view-section { margin-bottom:14px; }
        .view-label { font-size:10px; color:var(--text2); margin-bottom:8px; text-transform:uppercase; }
        .view-grid { display:grid; grid-template-columns:repeat(3,1fr); gap:6px; }
        .view-btn { padding:10px 8px; background:var(--surface); border:1px solid var(--border); border-radius:6px; color:var(--text2); font-size:11px; cursor:pointer; transition:all .15s; }
        .view-btn:hover { border-color:var(--text); color:var(--text); }
        .view-btn.active { background:var(--accent); color:#000; border-color:var(--accent); }
        .copper-toggle { margin-top:12px; padding-top:12px; border-top:1px solid var(--border); }
        .copper-btn { width:100%; padding:10px; background:var(--surface); border:1px solid var(--border); border-radius:6px; color:var(--text2); font-size:11px; cursor:pointer; }
        .copper-btn:hover { border-color:#f59e0b; color:#f59e0b; }
        .copper-btn.active { background:#b45309; color:#fff; border-color:#b45309; }
        .color-presets { display:flex; gap:8px; flex-wrap:wrap; }
        .color-preset { width:40px; height:40px; border-radius:8px; border:2px solid transparent; cursor:pointer; }
        .color-preset:hover { transform:scale(1.1); }
        .color-preset.active { border-color:#fff; box-shadow:0 0 0 2px var(--accent); }
        .preset-green { background:linear-gradient(135deg,#14532d 50%,#b45309 50%); }
        .preset-blue { background:linear-gradient(135deg,#1e3a8a 50%,#b45309 50%); }
        .preset-red { background:linear-gradient(135deg,#991b1b 50%,#b45309 50%); }
        .preset-black { background:linear-gradient(135deg,#171717 50%,#b45309 50%); }
        .preset-white { background:linear-gradient(135deg,#f5f5f4 50%,#78350f 50%); }
        .preset-purple { background:linear-gradient(135deg,#581c87 50%,#b45309 50%); }
        .stats-grid { display:grid; grid-template-columns:1fr 1fr; gap:10px; }
        .stat-item { background:var(--surface); border-radius:8px; padding:12px; }
        .stat-label { font-size:10px; color:var(--text2); text-transform:uppercase; margin-bottom:4px; }
        .stat-value { font-size:15px; font-weight:700; color:var(--accent); }
        .drill-table { width:100%; font-size:11px; margin-top:12px; }
        .drill-table th { text-align:left; padding:8px; background:var(--surface); color:var(--text2); }
        .drill-table td { padding:8px; border-bottom:1px solid var(--border); }
        main { display:flex; flex-direction:column; background:var(--bg); }
        .toolbar { display:flex; align-items:center; gap:6px; padding:10px 16px; background:var(--panel); border-bottom:1px solid var(--border); }
        .tool-btn { width:34px; height:34px; background:var(--surface); border:1px solid var(--border); border-radius:6px; color:var(--text2); cursor:pointer; font-size:16px; display:flex; align-items:center; justify-content:center; }
        .tool-btn:hover { border-color:var(--accent); color:var(--accent); }
        .tool-sep { width:1px; height:24px; background:var(--border); margin:0 4px; }
        .zoom-display { font-size:12px; color:var(--text); min-width:55px; text-align:center; }
        .canvas-container { flex:1; position:relative; overflow:hidden; }
        #canvas2d { position:absolute; top:0; left:0; width:100%; height:100%; cursor:grab; }
        #canvas3d { position:absolute; top:0; left:0; width:100%; height:100%; cursor:grab; display:none; }
        .view-mode-section { margin-bottom:14px; padding-bottom:14px; border-bottom:1px solid var(--border); }
        .view-mode-grid { display:grid; grid-template-columns:1fr 1fr; gap:6px; }
        .view-mode-btn { padding:12px 8px; background:var(--surface); border:1px solid var(--border); border-radius:6px; color:var(--text2); font-size:12px; cursor:pointer; transition:all .15s; display:flex; align-items:center; justify-content:center; gap:6px; }
        .view-mode-btn:hover { border-color:var(--text); color:var(--text); }
        .view-mode-btn.active { background:var(--accent); color:#000; border-color:var(--accent); }
        .empty-state { position:absolute; inset:0; display:flex; flex-direction:column; align-items:center; justify-content:center; color:var(--text2); }
        .empty-icon { font-size:72px; margin-bottom:20px; opacity:.2; }
        .empty-title { font-size:20px; margin-bottom:8px; color:var(--text); }
        .loading { position:absolute; inset:0; background:rgba(0,0,0,.9); display:none; place-items:center; z-index:100; }
        .loading.show { display:grid; }
        .spinner { width:44px; height:44px; border:3px solid var(--border); border-top-color:var(--accent); border-radius:50%; animation:spin .8s linear infinite; }
        @keyframes spin { to { transform:rotate(360deg); } }
    </style>
</head>
<body>
<div class="app">
    <header>
        <div class="logo"><div class="logo-icon">‚ó´</div>Gerber<span>Viewer</span><small style="color:var(--text2);margin-left:8px">v23</small></div>
        <div class="header-actions">
            <button class="btn" id="btnClear">üóëÔ∏è Pulisci</button>
            <button class="btn" id="btnExport">üì∑ Esporta</button>
        </div>
    </header>
    
    <aside class="sidebar">
        <div class="panel">
            <div class="panel-header">üìÅ File Gerber</div>
            <div class="panel-body">
                <div class="dropzone" id="dropzone">
                    <div class="dropzone-icon">üìÇ</div>
                    <div class="dropzone-title">Trascina file o clicca</div>
                    <div class="dropzone-subtitle">Gerber, Excellon, ZIP</div>
                    <input type="file" id="fileInput" multiple>
                </div>
                <div class="file-list" id="fileList"></div>
            </div>
        </div>
        
        <div class="panel">
            <div class="panel-header">üóÇÔ∏è Layer (<span id="layerCount">0</span>)</div>
            <div class="panel-body">
                <div class="layer-list" id="layerList"></div>
                <div class="layer-actions">
                    <button class="btn" id="btnShowAll">üëÅ Tutti</button>
                    <button class="btn" id="btnHideAll">üëÅ‚Äçüó® Nessuno</button>
                </div>
            </div>
        </div>
        
        <div class="panel">
            <div class="panel-header">üëÅ Vista</div>
            <div class="panel-body">
                <div class="view-mode-section">
                    <div class="view-label">Modalit√†</div>
                    <div class="view-mode-grid">
                        <button class="view-mode-btn active" data-mode="2d">üìê 2D</button>
                        <button class="view-mode-btn" data-mode="3d">üì¶ 3D</button>
                    </div>
                </div>
                <div class="view-section">
                    <div class="view-label">Lato</div>
                    <div class="view-grid">
                        <button class="view-btn active" data-view="top">Top</button>
                        <button class="view-btn" data-view="bottom">Bottom</button>
                        <button class="view-btn" data-view="all">Tutti</button>
                    </div>
                </div>
                <div class="view-section">
                    <div class="view-label">Rotazione</div>
                    <div class="view-grid">
                        <button class="view-btn active" data-rot="0">0¬∞</button>
                        <button class="view-btn" data-rot="90">90¬∞</button>
                        <button class="view-btn" data-rot="180">180¬∞</button>
                    </div>
                </div>
                <div class="copper-toggle">
                    <button class="copper-btn" id="btnCopperOnly">üî∂ Solo Rame</button>
                </div>
            </div>
        </div>
        
        <div class="panel">
            <div class="panel-header">üé® Colori PCB</div>
            <div class="panel-body">
                <div class="color-presets">
                    <div class="color-preset preset-green active" data-mask="#14532d" data-silk="#f5f5f4" title="Verde"></div>
                    <div class="color-preset preset-blue" data-mask="#1e3a8a" data-silk="#f5f5f4" title="Blu"></div>
                    <div class="color-preset preset-red" data-mask="#991b1b" data-silk="#f5f5f4" title="Rosso"></div>
                    <div class="color-preset preset-black" data-mask="#171717" data-silk="#f5f5f4" title="Nero"></div>
                    <div class="color-preset preset-white" data-mask="#f5f5f4" data-silk="#171717" title="Bianco"></div>
                    <div class="color-preset preset-purple" data-mask="#581c87" data-silk="#f5f5f4" title="Viola"></div>
                </div>
            </div>
        </div>
        
        <div class="panel">
            <div class="panel-header">üìä Statistiche</div>
            <div class="panel-body">
                <div class="stats-grid">
                    <div class="stat-item"><div class="stat-label">Dimensione</div><div class="stat-value" id="statSize">-</div></div>
                    <div class="stat-item"><div class="stat-label">Fori</div><div class="stat-value" id="statHoles">-</div></div>
                </div>
                <table class="drill-table" id="drillTable" style="display:none">
                    <thead><tr><th>Tool</th><th>√ò mm</th><th>Qty</th></tr></thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
    </aside>
    
    <main>
        <div class="toolbar">
            <button class="tool-btn" id="btnZoomIn" title="Zoom +">+</button>
            <button class="tool-btn" id="btnZoomOut" title="Zoom -">‚àí</button>
            <button class="tool-btn" id="btnFit" title="Adatta">‚ä°</button>
            <span class="zoom-display" id="zoomDisplay">100%</span>
            <div class="tool-sep"></div>
            <button class="tool-btn" id="btnFlipH" title="Specchia H">‚Üî</button>
            <button class="tool-btn" id="btnFlipV" title="Specchia V">‚Üï</button>
        </div>
        <div class="canvas-container" id="canvasContainer">
            <canvas id="canvas2d" style="display:none"></canvas>
            <canvas id="canvas3d"></canvas>
            <div class="empty-state" id="emptyState">
                <div class="empty-icon">‚ó´</div>
                <div class="empty-title">Carica file Gerber</div>
                <div>Trascina file o usa il pannello laterale</div>
            </div>
            <div class="loading" id="loading"><div class="spinner"></div></div>
        </div>
    </main>
</div>

<script>
class GerberViewer {
    constructor() {
        this.canvas2d = document.getElementById('canvas2d');
        this.ctx = this.canvas2d.getContext('2d');
        this.canvas3d = document.getElementById('canvas3d');
        this.files = [];
        this.layers = [];
        this.bounds = null;
        this.boardOutline = null;
        this.zoom = 1;
        this.pan = {x:0, y:0};
        this.ppm = 10;
        this.rotation = 0;
        this.flipH = false;
        this.flipV = false;
        this.colors = { bg:'#0c0c0c', mask:'#14532d', silk:'#f5f5f4', copper:'#b45309' };
        this.copperOnly = false;
        this.viewMode = '2d';

        // Three.js components
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.controls = null;
        this.pcbGroup = null;
        this.animationId = null;

        this.setupEvents();
        this.init3D();
    }
    
    setupEvents() {
        const dropzone = document.getElementById('dropzone');
        const fileInput = document.getElementById('fileInput');
        
        dropzone.onclick = () => fileInput.click();
        dropzone.ondragover = e => { e.preventDefault(); dropzone.classList.add('over'); };
        dropzone.ondragleave = () => dropzone.classList.remove('over');
        dropzone.ondrop = e => { e.preventDefault(); dropzone.classList.remove('over'); this.loadFiles(e.dataTransfer.files); };
        fileInput.onchange = () => this.loadFiles(fileInput.files);
        
        document.getElementById('btnClear').onclick = () => this.clear();
        document.getElementById('btnExport').onclick = () => this.exportPng();
        document.getElementById('btnShowAll').onclick = () => this.setAllLayersVisible(true);
        document.getElementById('btnHideAll').onclick = () => this.setAllLayersVisible(false);
        document.getElementById('btnZoomIn').onclick = () => this.setZoom(this.zoom*1.3);
        document.getElementById('btnZoomOut').onclick = () => this.setZoom(this.zoom/1.3);
        document.getElementById('btnFit').onclick = () => this.fit();
        document.getElementById('btnFlipH').onclick = () => {
            this.flipH = !this.flipH;
            this.render();
            if (this.viewMode === '3d') this.render3D();
        };
        document.getElementById('btnFlipV').onclick = () => {
            this.flipV = !this.flipV;
            this.render();
            if (this.viewMode === '3d') this.render3D();
        };

        document.getElementById('btnCopperOnly').onclick = () => {
            this.copperOnly = !this.copperOnly;
            document.getElementById('btnCopperOnly').classList.toggle('active', this.copperOnly);
            this.render();
            if (this.viewMode === '3d') this.build3DModel();
        };

        document.querySelectorAll('.view-btn[data-view]').forEach(btn => {
            btn.onclick = () => {
                document.querySelectorAll('.view-btn[data-view]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                this.setView(btn.dataset.view);
            };
        });

        document.querySelectorAll('.view-btn[data-rot]').forEach(btn => {
            btn.onclick = () => {
                document.querySelectorAll('.view-btn[data-rot]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                this.rotation = parseInt(btn.dataset.rot);
                this.render();
                if (this.viewMode === '3d') this.render3D();
            };
        });
        
        document.querySelectorAll('.color-preset').forEach(preset => {
            preset.onclick = () => {
                document.querySelectorAll('.color-preset').forEach(p => p.classList.remove('active'));
                preset.classList.add('active');
                this.colors.mask = preset.dataset.mask;
                this.colors.silk = preset.dataset.silk;
                this.layers.forEach(l => {
                    if (l.type==='mask') l.color = this.colors.mask;
                    if (l.type==='silk') l.color = this.colors.silk;
                });
                this.updateLayerList();
                this.render();
                if (this.viewMode === '3d') this.build3DModel();
            };
        });

        // View mode toggle (2D/3D)
        document.querySelectorAll('.view-mode-btn').forEach(btn => {
            btn.onclick = () => {
                document.querySelectorAll('.view-mode-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                this.setViewMode(btn.dataset.mode);
            };
        });
        
        const container = document.getElementById('canvasContainer');
        container.onwheel = e => { e.preventDefault(); this.setZoom(this.zoom * (e.deltaY < 0 ? 1.15 : 0.87)); };
        container.onmousedown = e => { this.drag = true; this.lastMouse = {x:e.clientX, y:e.clientY}; this.canvas2d.style.cursor = 'grabbing'; };
        container.onmousemove = e => {
            if (!this.drag) return;
            this.pan.x += e.clientX - this.lastMouse.x;
            this.pan.y += e.clientY - this.lastMouse.y;
            this.render();
            this.lastMouse = {x:e.clientX, y:e.clientY};
        };
        container.onmouseup = container.onmouseleave = () => { this.drag = false; this.canvas2d.style.cursor = 'grab'; };
        window.onresize = () => {
            if (this.layers.length) {
                this.fit();
                if (this.viewMode === '3d') this.resize3D();
            }
        };
    }

    init3D() {
        const rect = document.getElementById('canvasContainer').getBoundingClientRect();

        // Scene
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(this.colors.bg);

        // Camera
        this.camera = new THREE.PerspectiveCamera(45, rect.width / rect.height, 0.1, 10000);
        this.camera.position.set(0, 0, 100);

        // Renderer
        this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas3d, antialias: true });
        this.renderer.setSize(rect.width, rect.height);
        this.renderer.setPixelRatio(window.devicePixelRatio);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        this.scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 50, 100);
        this.scene.add(directionalLight);

        const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
        backLight.position.set(-50, -50, -100);
        this.scene.add(backLight);

        // PCB Group
        this.pcbGroup = new THREE.Group();
        this.scene.add(this.pcbGroup);

        // 3D controls with rotation and pan
        this.controls3D = {
            isDragging: false,
            isPanning: false,
            previousMousePosition: { x: 0, y: 0 },
            rotationSpeed: 0.005,
            panSpeed: 0.5,
            targetRotation: { x: -Math.PI / 6, y: 0 },
            targetPan: { x: 0, y: 0 }
        };

        this.canvas3d.addEventListener('mousedown', (e) => {
            if (this.viewMode !== '3d') return;
            // Right click or Shift+Left click = pan
            if (e.button === 2 || e.shiftKey) {
                this.controls3D.isPanning = true;
            } else {
                this.controls3D.isDragging = true;
            }
            this.controls3D.previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        this.canvas3d.addEventListener('mousemove', (e) => {
            if (this.viewMode !== '3d') return;
            const deltaX = e.clientX - this.controls3D.previousMousePosition.x;
            const deltaY = e.clientY - this.controls3D.previousMousePosition.y;

            if (this.controls3D.isPanning) {
                // Pan the view
                this.controls3D.targetPan.x += deltaX * this.controls3D.panSpeed / this.camera.position.z * 10;
                this.controls3D.targetPan.y -= deltaY * this.controls3D.panSpeed / this.camera.position.z * 10;
                this.render3D();
            } else if (this.controls3D.isDragging) {
                // Rotate the view
                this.controls3D.targetRotation.y += deltaX * this.controls3D.rotationSpeed;
                this.controls3D.targetRotation.x += deltaY * this.controls3D.rotationSpeed;
                this.render3D();
            }

            this.controls3D.previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        this.canvas3d.addEventListener('mouseup', () => {
            this.controls3D.isDragging = false;
            this.controls3D.isPanning = false;
        });

        this.canvas3d.addEventListener('mouseleave', () => {
            this.controls3D.isDragging = false;
            this.controls3D.isPanning = false;
        });

        // Prevent context menu on right click
        this.canvas3d.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        this.canvas3d.addEventListener('wheel', (e) => {
            if (this.viewMode !== '3d') return;
            e.preventDefault();
            const zoomFactor = e.deltaY > 0 ? 1.1 : 0.9;
            this.camera.position.z = Math.max(10, Math.min(500, this.camera.position.z * zoomFactor));
            this.render3D();
        });
    }

    resize3D() {
        const rect = document.getElementById('canvasContainer').getBoundingClientRect();
        this.camera.aspect = rect.width / rect.height;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(rect.width, rect.height);
        this.render3D();
    }

    setViewMode(mode) {
        this.viewMode = mode;
        if (mode === '2d') {
            this.canvas2d.style.display = this.layers.length ? 'block' : 'none';
            this.canvas3d.style.display = 'none';
            this.render();
        } else {
            this.canvas2d.style.display = 'none';
            this.canvas3d.style.display = this.layers.length ? 'block' : 'none';
            if (this.layers.length) {
                // In 3D mode, show all layers by default
                document.querySelectorAll('.view-btn[data-view]').forEach(b => b.classList.remove('active'));
                document.querySelector('.view-btn[data-view="all"]').classList.add('active');
                this.layers.forEach(l => l.visible = true);
                this.updateLayerList();
                this.resize3D();
                this.build3DModel();
            }
        }
    }

    build3DModel() {
        if (!this.bounds || !this.layers.length) return;

        // Clear existing model
        while (this.pcbGroup.children.length > 0) {
            const child = this.pcbGroup.children[0];
            if (child.geometry) child.geometry.dispose();
            if (child.material) {
                if (Array.isArray(child.material)) {
                    child.material.forEach(m => m.dispose());
                } else {
                    child.material.dispose();
                }
            }
            this.pcbGroup.remove(child);
        }

        // Reset pan position
        this.controls3D.targetPan = { x: 0, y: 0 };

        const bw = this.bounds.maxX - this.bounds.minX;
        const bh = this.bounds.maxY - this.bounds.minY;
        const centerX = (this.bounds.minX + this.bounds.maxX) / 2;
        const centerY = (this.bounds.minY + this.bounds.maxY) / 2;
        const scale = 1;

        // PCB thickness in mm - increased for better z-buffer separation
        const pcbThickness = 1.6;
        const copperThickness = 0.07;  // Increased from 0.035
        const maskThickness = 0.05;    // Increased from 0.02
        const silkThickness = 0.03;    // Increased from 0.01

        // Board outline shape
        let boardShape;
        if (this.boardOutline && this.boardOutline.length >= 3) {
            boardShape = new THREE.Shape();
            boardShape.moveTo((this.boardOutline[0].x - centerX) * scale, (this.boardOutline[0].y - centerY) * scale);
            for (let i = 1; i < this.boardOutline.length; i++) {
                boardShape.lineTo((this.boardOutline[i].x - centerX) * scale, (this.boardOutline[i].y - centerY) * scale);
            }
            boardShape.closePath();
        } else {
            // Fallback to rectangular board
            boardShape = new THREE.Shape();
            boardShape.moveTo(-bw/2 * scale, -bh/2 * scale);
            boardShape.lineTo(bw/2 * scale, -bh/2 * scale);
            boardShape.lineTo(bw/2 * scale, bh/2 * scale);
            boardShape.lineTo(-bw/2 * scale, bh/2 * scale);
            boardShape.closePath();
        }

        // FR4 substrate (board base)
        const fr4Material = new THREE.MeshPhongMaterial({
            color: 0xc19a6b,
            shininess: 10,
            side: THREE.DoubleSide
        });
        const boardGeom = new THREE.ExtrudeGeometry(boardShape, {
            depth: pcbThickness,
            bevelEnabled: false
        });
        const boardMesh = new THREE.Mesh(boardGeom, fr4Material);
        boardMesh.position.z = -pcbThickness / 2;
        this.pcbGroup.add(boardMesh);

        // Sorted layers
        const sorted = [...this.layers].sort((a, b) => a.order - b.order);

        // Get current view filter
        const viewBtn = document.querySelector('.view-btn[data-view].active');
        const currentView = viewBtn ? viewBtn.dataset.view : 'top';

        // Build copper layers first
        for (const layer of sorted) {
            if (!layer.visible) continue;
            if (layer.type !== 'copper') continue;

            const isTop = layer.side === 'top' || layer.side === 'both';
            const zPos = isTop ? pcbThickness/2 + copperThickness/2 : -pcbThickness/2 - copperThickness/2;
            this.buildLayerGeometry(layer, centerX, centerY, scale, zPos, isTop);
        }

        // Build solder mask (only if not copperOnly mode)
        if (!this.copperOnly) {
            for (const layer of sorted) {
                if (!layer.visible) continue;
                if (layer.type !== 'mask') continue;

                const isTop = layer.side === 'top';
                const zPos = isTop ? pcbThickness/2 + copperThickness + maskThickness/2 : -pcbThickness/2 - copperThickness - maskThickness/2;

                // First render the solid mask surface
                this.buildSolderMask3D(layer, boardShape, centerX, centerY, scale, zPos, maskThickness);

                // Then render the mask openings (pad exposures) as copper-colored geometry on top
                const openingZPos = isTop ? pcbThickness/2 + copperThickness + maskThickness + 0.01 : -pcbThickness/2 - copperThickness - maskThickness - 0.01;
                this.buildMaskOpenings3D(layer, centerX, centerY, scale, openingZPos);
            }

            // Build silkscreen layers
            for (const layer of sorted) {
                if (!layer.visible) continue;
                if (layer.type !== 'silk') continue;

                const isTop = layer.side === 'top' || layer.side === 'both';
                const zPos = isTop ? pcbThickness/2 + copperThickness + maskThickness + silkThickness/2 : -pcbThickness/2 - copperThickness - maskThickness - silkThickness/2;
                this.buildLayerGeometry(layer, centerX, centerY, scale, zPos, isTop);
            }
        }

        // Add drill holes
        for (const layer of sorted) {
            if (layer.type === 'drill' && layer.visible) {
                this.buildDrillHoles(layer, centerX, centerY, scale, pcbThickness);
            }
        }

        // Apply rotation and flip
        this.pcbGroup.rotation.x = this.controls3D.targetRotation.x;
        this.pcbGroup.rotation.y = this.controls3D.targetRotation.y;

        // Apply view rotation
        if (this.rotation === 90) {
            this.pcbGroup.rotation.z = Math.PI / 2;
        } else if (this.rotation === 180) {
            this.pcbGroup.rotation.z = Math.PI;
        } else {
            this.pcbGroup.rotation.z = 0;
        }

        // Apply flip
        this.pcbGroup.scale.x = this.flipH ? -1 : 1;
        this.pcbGroup.scale.y = this.flipV ? -1 : 1;

        // Fit camera
        const maxDim = Math.max(bw, bh);
        this.camera.position.z = maxDim * 2;

        this.render3D();
    }

    buildLayerGeometry(layer, centerX, centerY, scale, zPos, isTop) {
        const color = new THREE.Color(layer.color);
        const thickness = layer.type === 'copper' ? 0.07 : (layer.type === 'silk' ? 0.03 : 0.05);

        // Create material with polygonOffset to prevent z-fighting
        const material = new THREE.MeshPhongMaterial({
            color: color,
            shininess: layer.type === 'copper' ? 80 : 30,
            transparent: layer.type === 'mask',
            opacity: layer.type === 'mask' ? 0.85 : 1,
            side: THREE.DoubleSide,
            polygonOffset: true,
            polygonOffsetFactor: layer.type === 'copper' ? -1 : (layer.type === 'silk' ? -3 : -2),
            polygonOffsetUnits: -1
        });

        // Process commands
        for (const cmd of layer.cmds) {
            if (cmd.polarity === 'clear') continue;

            if (cmd.type === 'flash') {
                this.addFlash3D(cmd, centerX, centerY, scale, zPos, thickness, material);
            } else if (cmd.type === 'line') {
                this.addLine3D(cmd, centerX, centerY, scale, zPos, thickness, material);
            } else if (cmd.type === 'arc') {
                this.addArc3D(cmd, centerX, centerY, scale, zPos, thickness, material);
            } else if (cmd.type === 'region' && cmd.points && cmd.points.length >= 3) {
                this.addRegion3D(cmd, centerX, centerY, scale, zPos, thickness, material);
            }
        }
    }

    buildSolderMask3D(layer, boardShape, centerX, centerY, scale, zPos, thickness) {
        // Create solder mask as a solid surface covering the board
        const maskMaterial = new THREE.MeshPhongMaterial({
            color: new THREE.Color(layer.color),
            shininess: 30,
            transparent: true,
            opacity: 0.9,
            side: THREE.DoubleSide,
            polygonOffset: true,
            polygonOffsetFactor: -2,
            polygonOffsetUnits: -1
        });

        try {
            const maskGeom = new THREE.ExtrudeGeometry(boardShape, {
                depth: thickness,
                bevelEnabled: false
            });
            const maskMesh = new THREE.Mesh(maskGeom, maskMaterial);
            maskMesh.position.z = zPos - thickness / 2;
            this.pcbGroup.add(maskMesh);
        } catch(e) {
            // Fallback if board shape fails
        }
    }

    buildMaskOpenings3D(layer, centerX, centerY, scale, zPos) {
        // Render mask openings as copper-colored pads (HASL finish appearance)
        const thickness = 0.02;
        const material = new THREE.MeshPhongMaterial({
            color: new THREE.Color(this.colors.copper),
            shininess: 90,
            side: THREE.DoubleSide,
            polygonOffset: true,
            polygonOffsetFactor: -6,
            polygonOffsetUnits: -1
        });

        for (const cmd of layer.cmds) {
            if (cmd.polarity === 'clear') continue;

            if (cmd.type === 'flash') {
                this.addFlash3D(cmd, centerX, centerY, scale, zPos, thickness, material);
            } else if (cmd.type === 'line') {
                this.addLine3D(cmd, centerX, centerY, scale, zPos, thickness, material);
            } else if (cmd.type === 'region' && cmd.points && cmd.points.length >= 3) {
                this.addRegion3D(cmd, centerX, centerY, scale, zPos, thickness, material);
            }
        }
    }

    addFlash3D(cmd, centerX, centerY, scale, zPos, thickness, material) {
        const x = (cmd.x - centerX) * scale;
        const y = (cmd.y - centerY) * scale;
        const ap = cmd.aperture;
        let geometry;

        if (ap.type === 'C') {
            const radius = (ap.params[0] || 0.5) / 2 * scale;
            geometry = new THREE.CylinderGeometry(radius, radius, thickness, 24);
            geometry.rotateX(Math.PI / 2);
        } else if (ap.type === 'R') {
            const w = (ap.params[0] || 0.5) * scale;
            const h = (ap.params[1] || ap.params[0] || 0.5) * scale;
            geometry = new THREE.BoxGeometry(w, h, thickness);
        } else if (ap.type === 'O') {
            // Obround - elongated pad with rounded ends
            const w = (ap.params[0] || 0.5) * scale;
            const h = (ap.params[1] || ap.params[0] || 0.5) * scale;
            if (Math.abs(w - h) < 0.001) {
                geometry = new THREE.CylinderGeometry(w/2, w/2, thickness, 24);
                geometry.rotateX(Math.PI / 2);
            } else {
                // Create obround shape (stadium shape)
                const shape = new THREE.Shape();
                if (w > h) {
                    const r = h / 2;
                    const dx = (w - h) / 2;
                    shape.moveTo(-dx, -r);
                    shape.lineTo(dx, -r);
                    shape.absarc(dx, 0, r, -Math.PI/2, Math.PI/2, false);
                    shape.lineTo(-dx, r);
                    shape.absarc(-dx, 0, r, Math.PI/2, -Math.PI/2, false);
                } else {
                    const r = w / 2;
                    const dy = (h - w) / 2;
                    shape.moveTo(r, -dy);
                    shape.lineTo(r, dy);
                    shape.absarc(0, dy, r, 0, Math.PI, false);
                    shape.lineTo(-r, -dy);
                    shape.absarc(0, -dy, r, Math.PI, 0, false);
                }
                shape.closePath();
                geometry = new THREE.ExtrudeGeometry(shape, { depth: thickness, bevelEnabled: false });
                geometry.translate(0, 0, -thickness/2);
            }
        } else if (ap.type === 'P') {
            // Regular polygon
            const od = (ap.params[0] || 0.5) * scale;
            const vertices = ap.params[1] || 4;
            geometry = new THREE.CylinderGeometry(od/2, od/2, thickness, vertices);
            geometry.rotateX(Math.PI / 2);
        } else if (ap.type === 'POLY' && ap.vertices) {
            // Custom polygon from macro
            const shape = new THREE.Shape();
            shape.moveTo(ap.vertices[0].x * scale, ap.vertices[0].y * scale);
            for (let i = 1; i < ap.vertices.length; i++) {
                shape.lineTo(ap.vertices[i].x * scale, ap.vertices[i].y * scale);
            }
            shape.closePath();
            geometry = new THREE.ExtrudeGeometry(shape, { depth: thickness, bevelEnabled: false });
            geometry.translate(0, 0, -thickness/2);
        } else {
            // Fallback to circle
            const radius = (ap.params[0] || 0.5) / 2 * scale;
            geometry = new THREE.CylinderGeometry(radius, radius, thickness, 24);
            geometry.rotateX(Math.PI / 2);
        }

        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(x, y, zPos);
        if (ap.rotation) mesh.rotation.z = ap.rotation * Math.PI / 180;
        mesh.matrixAutoUpdate = false;
        mesh.updateMatrix();
        this.pcbGroup.add(mesh);
    }

    addLine3D(cmd, centerX, centerY, scale, zPos, thickness, material) {
        const x1 = (cmd.x1 - centerX) * scale;
        const y1 = (cmd.y1 - centerY) * scale;
        const x2 = (cmd.x2 - centerX) * scale;
        const y2 = (cmd.y2 - centerY) * scale;
        const width = (cmd.width || 0.1) * scale;
        const radius = width / 2;

        const length = Math.sqrt((x2-x1)**2 + (y2-y1)**2);
        if (length < 0.001) return;

        const angle = Math.atan2(y2 - y1, x2 - x1);

        // Create rounded trace shape (stadium/obround)
        const traceShape = new THREE.Shape();
        const halfLen = length / 2;
        traceShape.moveTo(-halfLen, -radius);
        traceShape.lineTo(halfLen, -radius);
        traceShape.absarc(halfLen, 0, radius, -Math.PI/2, Math.PI/2, false);
        traceShape.lineTo(-halfLen, radius);
        traceShape.absarc(-halfLen, 0, radius, Math.PI/2, -Math.PI/2, false);
        traceShape.closePath();

        const geometry = new THREE.ExtrudeGeometry(traceShape, { depth: thickness, bevelEnabled: false });
        geometry.translate(0, 0, -thickness/2);
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set((x1 + x2) / 2, (y1 + y2) / 2, zPos);
        mesh.rotation.z = angle;
        mesh.matrixAutoUpdate = false;
        mesh.updateMatrix();
        this.pcbGroup.add(mesh);
    }

    addArc3D(cmd, centerX, centerY, scale, zPos, thickness, material) {
        const pts = this.arcToPoints(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.i, cmd.j, cmd.cw);
        const width = (cmd.width || 0.1) * scale;
        const radius = width / 2;

        // Build arc as a series of connected segments
        const allPts = [{ x: cmd.x1, y: cmd.y1 }, ...pts];

        // Sample points for performance
        const step = Math.max(1, Math.floor(allPts.length / 20));
        const sampledPts = [];
        for (let i = 0; i < allPts.length; i += step) {
            sampledPts.push(allPts[i]);
        }
        if (sampledPts[sampledPts.length - 1] !== allPts[allPts.length - 1]) {
            sampledPts.push(allPts[allPts.length - 1]);
        }

        for (let i = 0; i < sampledPts.length - 1; i++) {
            const x1 = (sampledPts[i].x - centerX) * scale;
            const y1 = (sampledPts[i].y - centerY) * scale;
            const x2 = (sampledPts[i + 1].x - centerX) * scale;
            const y2 = (sampledPts[i + 1].y - centerY) * scale;

            const length = Math.sqrt((x2-x1)**2 + (y2-y1)**2);
            if (length < 0.001) continue;

            const angle = Math.atan2(y2 - y1, x2 - x1);

            // Rounded segment
            const segShape = new THREE.Shape();
            const halfLen = length / 2;
            segShape.moveTo(-halfLen, -radius);
            segShape.lineTo(halfLen, -radius);
            segShape.absarc(halfLen, 0, radius, -Math.PI/2, Math.PI/2, false);
            segShape.lineTo(-halfLen, radius);
            segShape.absarc(-halfLen, 0, radius, Math.PI/2, -Math.PI/2, false);
            segShape.closePath();

            const geometry = new THREE.ExtrudeGeometry(segShape, { depth: thickness, bevelEnabled: false });
            geometry.translate(0, 0, -thickness/2);
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set((x1 + x2) / 2, (y1 + y2) / 2, zPos);
            mesh.rotation.z = angle;
            mesh.matrixAutoUpdate = false;
            mesh.updateMatrix();
            this.pcbGroup.add(mesh);
        }
    }

    addRegion3D(cmd, centerX, centerY, scale, zPos, thickness, material) {
        const shape = new THREE.Shape();
        shape.moveTo((cmd.points[0].x - centerX) * scale, (cmd.points[0].y - centerY) * scale);
        for (let i = 1; i < cmd.points.length; i++) {
            shape.lineTo((cmd.points[i].x - centerX) * scale, (cmd.points[i].y - centerY) * scale);
        }
        shape.closePath();

        try {
            const geometry = new THREE.ExtrudeGeometry(shape, {
                depth: thickness,
                bevelEnabled: false
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.z = zPos - thickness / 2;
            mesh.matrixAutoUpdate = false;
            mesh.updateMatrix();
            this.pcbGroup.add(mesh);
        } catch(e) {
            // Skip invalid shapes
        }
    }

    buildDrillHoles(layer, centerX, centerY, scale, pcbThickness) {
        // Calculate z-positions - must be above all other layers
        const topZ = pcbThickness / 2 + 0.2;  // Above mask and silk
        const bottomZ = -pcbThickness / 2 - 0.2;

        // Dark material for hole interior
        const holeMaterial = new THREE.MeshBasicMaterial({
            color: 0x1a1a1a,
            side: THREE.DoubleSide
        });

        // Hole wall (inner cylinder wall) - metallic plated
        const wallMaterial = new THREE.MeshPhongMaterial({
            color: 0x888888,
            shininess: 60,
            side: THREE.DoubleSide
        });

        // Copper annular ring material
        const ringMaterial = new THREE.MeshPhongMaterial({
            color: new THREE.Color(this.colors.copper),
            shininess: 80,
            side: THREE.DoubleSide,
            polygonOffset: true,
            polygonOffsetFactor: -8,
            polygonOffsetUnits: -1
        });

        for (const cmd of layer.cmds) {
            if (cmd.type === 'drill') {
                const x = (cmd.x - centerX) * scale;
                const y = (cmd.y - centerY) * scale;
                const radius = (cmd.diameter / 2) * scale;
                const annularRing = 0.2 * scale;  // Copper ring width

                // Inner tube wall (plated through-hole)
                const tubeGeom = new THREE.CylinderGeometry(radius, radius, pcbThickness + 0.5, 32, 1, true);
                tubeGeom.rotateX(Math.PI / 2);
                const tubeMesh = new THREE.Mesh(tubeGeom, wallMaterial);
                tubeMesh.position.set(x, y, 0);
                tubeMesh.matrixAutoUpdate = false;
                tubeMesh.updateMatrix();
                this.pcbGroup.add(tubeMesh);

                // Dark circle on top (hole opening)
                const holeTopGeom = new THREE.CircleGeometry(radius, 32);
                const holeTop = new THREE.Mesh(holeTopGeom, holeMaterial);
                holeTop.position.set(x, y, topZ + 0.01);
                holeTop.matrixAutoUpdate = false;
                holeTop.updateMatrix();
                this.pcbGroup.add(holeTop);

                // Dark circle on bottom
                const holeBottom = new THREE.Mesh(holeTopGeom.clone(), holeMaterial);
                holeBottom.position.set(x, y, bottomZ - 0.01);
                holeBottom.rotation.x = Math.PI;
                holeBottom.matrixAutoUpdate = false;
                holeBottom.updateMatrix();
                this.pcbGroup.add(holeBottom);

                // Copper annular ring on top
                const ringGeom = new THREE.RingGeometry(radius, radius + annularRing, 32);
                const ringTop = new THREE.Mesh(ringGeom, ringMaterial);
                ringTop.position.set(x, y, topZ);
                ringTop.matrixAutoUpdate = false;
                ringTop.updateMatrix();
                this.pcbGroup.add(ringTop);

                // Copper annular ring on bottom
                const ringBottom = new THREE.Mesh(ringGeom.clone(), ringMaterial);
                ringBottom.position.set(x, y, bottomZ);
                ringBottom.rotation.x = Math.PI;
                ringBottom.matrixAutoUpdate = false;
                ringBottom.updateMatrix();
                this.pcbGroup.add(ringBottom);

            } else if (cmd.type === 'slot') {
                const x1 = (cmd.x1 - centerX) * scale;
                const y1 = (cmd.y1 - centerY) * scale;
                const x2 = (cmd.x2 - centerX) * scale;
                const y2 = (cmd.y2 - centerY) * scale;
                const radius = (cmd.diameter / 2) * scale;
                const length = Math.sqrt((x2-x1)**2 + (y2-y1)**2);
                const angle = Math.atan2(y2 - y1, x2 - x1);

                // Create slot shape (stadium/obround)
                const slotShape = new THREE.Shape();
                const halfLen = length / 2;
                slotShape.moveTo(-halfLen, -radius);
                slotShape.lineTo(halfLen, -radius);
                slotShape.absarc(halfLen, 0, radius, -Math.PI/2, Math.PI/2, false);
                slotShape.lineTo(-halfLen, radius);
                slotShape.absarc(-halfLen, 0, radius, Math.PI/2, -Math.PI/2, false);
                slotShape.closePath();

                // Slot wall
                const slotGeom = new THREE.ExtrudeGeometry(slotShape, { depth: pcbThickness + 0.5, bevelEnabled: false });
                slotGeom.translate(0, 0, -(pcbThickness + 0.5) / 2);
                const slotMesh = new THREE.Mesh(slotGeom, wallMaterial);
                slotMesh.position.set((x1 + x2) / 2, (y1 + y2) / 2, 0);
                slotMesh.rotation.z = angle;
                slotMesh.matrixAutoUpdate = false;
                slotMesh.updateMatrix();
                this.pcbGroup.add(slotMesh);

                // Dark top surface for slot
                const slotTopGeom = new THREE.ShapeGeometry(slotShape);
                const slotTop = new THREE.Mesh(slotTopGeom, holeMaterial);
                slotTop.position.set((x1 + x2) / 2, (y1 + y2) / 2, topZ + 0.01);
                slotTop.rotation.z = angle;
                slotTop.matrixAutoUpdate = false;
                slotTop.updateMatrix();
                this.pcbGroup.add(slotTop);
            }
        }
    }

    render3D() {
        if (!this.renderer || !this.scene || !this.camera) return;

        // Apply pan
        this.pcbGroup.position.x = this.controls3D.targetPan.x;
        this.pcbGroup.position.y = this.controls3D.targetPan.y;

        // Update group rotation from controls
        this.pcbGroup.rotation.x = this.controls3D.targetRotation.x;
        this.pcbGroup.rotation.y = this.controls3D.targetRotation.y;

        // Apply view rotation on top of orbit
        let baseRotZ = 0;
        if (this.rotation === 90) baseRotZ = Math.PI / 2;
        else if (this.rotation === 180) baseRotZ = Math.PI;
        this.pcbGroup.rotation.z = baseRotZ;

        // Apply flip
        this.pcbGroup.scale.x = this.flipH ? -1 : 1;
        this.pcbGroup.scale.y = this.flipV ? -1 : 1;

        this.renderer.render(this.scene, this.camera);
    }

    setView(view) {
        this.layers.forEach(l => {
            if (view === 'all') l.visible = true;
            else if (view === 'top') l.visible = l.side === 'top' || l.side === 'both';
            else if (view === 'bottom') l.visible = l.side === 'bottom' || l.side === 'both';
        });
        this.updateLayerList();
        this.render();
        if (this.viewMode === '3d') this.build3DModel();
    }
    
    async loadFiles(fileList) {
        document.getElementById('loading').classList.add('show');
        const files = [];
        for (const f of fileList) {
            if (f.name.toLowerCase().endsWith('.zip')) files.push(...await this.extractZip(f));
            else files.push(f);
        }
        for (const f of files) {
            try {
                const layer = this.parseFile(f.name, await f.text());
                if (layer?.cmds.length > 0) { this.files.push(f); this.layers.push(layer); }
            } catch(e) { console.error('Parse error:', f.name, e); }
        }
        this.extractBoardOutline();
        this.calcBounds();
        this.updateUI();
        this.updateStats();
        if (this.layers.length > 0) {
            document.getElementById('emptyState').style.display = 'none';
            if (this.viewMode === '2d') {
                this.canvas2d.style.display = 'block';
                this.canvas3d.style.display = 'none';
            } else {
                this.canvas2d.style.display = 'none';
                this.canvas3d.style.display = 'block';
            }
            this.setView('top');
            this.fit();
            if (this.viewMode === '3d') {
                this.resize3D();
                this.build3DModel();
            }
        }
        document.getElementById('loading').classList.remove('show');
    }
    
    async extractZip(zipFile) {
        const zip = await JSZip.loadAsync(zipFile);
        const files = [];
        const ext = ['gtl','gbl','gts','gbs','gto','gbo','drl','xln','gko','gm1','gbr','ger','gtp','gbp','txt','gdl','gme'];
        for (const [name, entry] of Object.entries(zip.files)) {
            if (!entry.dir && ext.includes(name.split('.').pop().toLowerCase())) {
                files.push(new File([await entry.async('string')], name.split('/').pop()));
            }
        }
        return files;
    }
    
    detectLayerType(name, ext) {
        const n = name.toLowerCase();
        if (n.includes('toplayer') || n.includes('top_copper') || n.includes('-f_cu') || ext==='gtl') return {type:'copper',side:'top',order:10};
        if (n.includes('bottomlayer') || n.includes('bottom_copper') || n.includes('-b_cu') || ext==='gbl') return {type:'copper',side:'bottom',order:11};
        if (n.includes('topsoldermask') || n.includes('topmask') || n.includes('-f_mask') || ext==='gts') return {type:'mask',side:'top',order:20};
        if (n.includes('bottomsoldermask') || n.includes('bottommask') || n.includes('-b_mask') || ext==='gbs') return {type:'mask',side:'bottom',order:21};
        if (n.includes('topsilk') || n.includes('-f_silks') || ext==='gto') return {type:'silk',side:'top',order:30};
        if (n.includes('bottomsilk') || n.includes('-b_silks') || ext==='gbo') return {type:'silk',side:'bottom',order:31};
        if (n.includes('outline') || n.includes('edge') || n.includes('boardoutline') || n.includes('profile') || ext==='gko' || ext==='gm1') return {type:'outline',side:'both',order:0};
        if (n.includes('drill') || ext==='drl' || ext==='xln') return {type:'drill',side:'both',order:50};
        return {type:'unknown',side:'both',order:100};
    }
    
    getLayerColor(type) {
        return {copper:this.colors.copper, mask:this.colors.mask, silk:this.colors.silk, outline:'#facc15'}[type] || '#666';
    }
    
    parseFile(name, text) {
        const ext = name.toLowerCase().split('.').pop();
        const info = this.detectLayerType(name, ext);
        info.color = this.getLayerColor(info.type);
        
        const isDrill = (ext==='drl' || ext==='xln' || text.includes('M48'));
        
        return isDrill ? this.parseDrill(name, text, info) : this.parseGerber(name, text, info);
    }
    
    parseGerber(name, text, info) {
        // Format defaults
        let xInt = 2, xDec = 4, unit = 'mm';
        const apertures = {};
        const macros = {};
        let curAp = null, x = 0, y = 0, interp = 'linear', polarity = 'dark';
        let inRegion = false, regionPts = [];
        const cmds = [];
        
        // Calculate coordinate divisor based on decimal places
        const getScale = () => Math.pow(10, xDec) * (unit === 'in' ? 1/25.4 : 1);
        
        // Parse coordinate string to mm
        const parseCoord = (s) => {
            if (!s) return null;
            const neg = s.startsWith('-');
            if (neg) s = s.slice(1);
            // Pad to full length
            s = s.padStart(xInt + xDec, '0');
            const intPart = s.slice(0, s.length - xDec);
            const decPart = s.slice(s.length - xDec);
            let val = parseFloat(intPart + '.' + decPart);
            if (neg) val = -val;
            return unit === 'in' ? val * 25.4 : val;
        };
        
        // First pass: extract macros
        const macroRegex = /%AM([A-Za-z_][A-Za-z0-9_]*)\*([^%]*?)%/gs;
        let match;
        while ((match = macroRegex.exec(text)) !== null) {
            macros[match[1]] = match[2];
        }
        
        // Process lines
        const lines = text.split(/\r?\n/);
        for (const line of lines) {
            const l = line.trim();
            if (!l || l.startsWith('G04')) continue;
            
            // Format spec: %FSLAX45Y45*%
            let m = l.match(/%FSLAX(\d)(\d)Y\d+\*%/);
            if (m) { xInt = +m[1]; xDec = +m[2]; continue; }
            
            // Unit
            if (l.includes('%MOMM')) { unit = 'mm'; continue; }
            if (l.includes('%MOIN')) { unit = 'in'; continue; }
            
            // Standard aperture: %ADD10C,0.5*% or %ADD10R,1.0X0.5*%
            m = l.match(/%ADD(\d+)([CROP]),?([^*]*)\*%/);
            if (m) {
                const num = m[1], type = m[2];
                const params = m[3] ? m[3].split('X').map(Number) : [0];
                apertures[num] = { type, params, rotation: 0 };
                continue;
            }
            
            // Macro aperture: %ADD12MACRO1,0.5X0.8X90*%
            m = l.match(/%ADD(\d+)([A-Za-z_][A-Za-z0-9_]*),?([^*]*)\*%/);
            if (m && !['C','R','O','P'].includes(m[2])) {
                const num = m[1], macroName = m[2];
                const params = m[3] ? m[3].split('X').map(Number) : [];
                
                if (macros[macroName]) {
                    apertures[num] = this.evaluateMacro(macros[macroName], params);
                } else {
                    // Unknown macro, fallback
                    apertures[num] = { type: 'C', params: [0.5], rotation: 0 };
                }
                continue;
            }
            
            // Polarity
            if (l.includes('%LPD')) { polarity = 'dark'; continue; }
            if (l.includes('%LPC')) { polarity = 'clear'; continue; }
            
            // Process commands
            for (const cmd of l.split('*').filter(c => c.trim())) {
                const c = cmd.trim();
                
                // Interpolation mode
                if (c === 'G01' || c === 'G1') { interp = 'linear'; continue; }
                if (c === 'G02' || c === 'G2') { interp = 'cw'; continue; }
                if (c === 'G03' || c === 'G3') { interp = 'ccw'; continue; }
                if (c === 'G74' || c === 'G75') continue;
                
                // Region
                if (c === 'G36') { inRegion = true; regionPts = []; continue; }
                if (c === 'G37') {
                    if (regionPts.length >= 3) {
                        cmds.push({ type: 'region', points: [...regionPts], polarity });
                    }
                    inRegion = false;
                    continue;
                }
                
                // Aperture select: D10, D11, etc.
                m = c.match(/^D(\d+)$/);
                if (m && +m[1] >= 10) { curAp = m[1]; continue; }
                
                // Coordinate move/draw
                m = c.match(/^(?:G0?([123]))?(?:X(-?\d+))?(?:Y(-?\d+))?(?:I(-?\d+))?(?:J(-?\d+))?(?:D0?([123]))?$/);
                if (m && (m[2] || m[3] || m[6])) {
                    // Update interpolation if specified
                    if (m[1]) {
                        if (m[1] === '1') interp = 'linear';
                        else if (m[1] === '2') interp = 'cw';
                        else if (m[1] === '3') interp = 'ccw';
                    }
                    
                    const ox = x, oy = y;
                    if (m[2]) x = parseCoord(m[2]);
                    if (m[3]) y = parseCoord(m[3]);
                    const i = m[4] ? parseCoord(m[4]) : 0;
                    const j = m[5] ? parseCoord(m[5]) : 0;
                    const d = m[6] ? +m[6] : null;
                    
                    if (inRegion) {
                        if (d === 2) {
                            // Move - start new region
                            if (regionPts.length >= 3) {
                                cmds.push({ type: 'region', points: [...regionPts], polarity });
                            }
                            regionPts = [{ x, y }];
                        } else if (d === 1 || d === null) {
                            if (!regionPts.length) regionPts.push({ x: ox, y: oy });
                            if (interp === 'linear') {
                                regionPts.push({ x, y });
                            } else {
                                regionPts.push(...this.arcToPoints(ox, oy, x, y, i, j, interp === 'cw'));
                            }
                        }
                    } else {
                        if (d === 1) {
                            // Draw
                            const ap = apertures[curAp] || { type: 'C', params: [0.1] };
                            if (interp === 'linear') {
                                cmds.push({ type: 'line', x1: ox, y1: oy, x2: x, y2: y, width: ap.params[0] || 0.1, polarity });
                            } else {
                                cmds.push({ type: 'arc', x1: ox, y1: oy, x2: x, y2: y, i, j, cw: interp === 'cw', width: ap.params[0] || 0.1, polarity });
                            }
                        } else if (d === 3) {
                            // Flash
                            const ap = apertures[curAp] || { type: 'C', params: [0.5] };
                            cmds.push({ type: 'flash', x, y, aperture: ap, polarity });
                        }
                    }
                }
            }
        }
        
        console.log(`[${name}] Format: ${xInt}.${xDec}, Unit: ${unit}, Apertures: ${Object.keys(apertures).length}, Commands: ${cmds.length}`);
        return { name, ...info, cmds, visible: true };
    }
    
    evaluateMacro(macroBody, params) {
        // Parse macro primitives and evaluate with parameters
        const primitives = macroBody.split('*').filter(p => p.trim());
        
        // Function to evaluate expression with $n variables
        const evalExpr = (expr) => {
            if (expr === undefined || expr === null) return 0;
            let s = String(expr).trim();
            // Replace $n with parameter values
            s = s.replace(/\$(\d+)/g, (_, n) => {
                const idx = parseInt(n) - 1;
                return params[idx] !== undefined ? params[idx] : 0;
            });
            // Handle 'x' as multiply
            s = s.replace(/x/gi, '*');
            try {
                return eval(s);
            } catch {
                return parseFloat(s) || 0;
            }
        };
        
        for (const prim of primitives) {
            const p = prim.trim();
            if (!p || p.startsWith('0')) continue; // Skip comments
            
            const parts = p.split(',');
            const code = parseInt(parts[0]);
            
            if (code === 1) {
                // Circle: 1,exposure,diameter,cx,cy[,rotation]
                const d = evalExpr(parts[2]);
                return { type: 'C', params: [d], rotation: 0 };
            } else if (code === 4) {
                // Outline: 4,exposure,n_vertices,x0,y0,x1,y1,...,rotation
                const nVerts = parseInt(parts[2]) || 0;
                const vertices = [];
                for (let i = 0; i <= nVerts; i++) {
                    vertices.push({
                        x: evalExpr(parts[3 + i * 2]),
                        y: evalExpr(parts[4 + i * 2])
                    });
                }
                // Calculate bounding box
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                for (const v of vertices) {
                    if (v.x < minX) minX = v.x;
                    if (v.y < minY) minY = v.y;
                    if (v.x > maxX) maxX = v.x;
                    if (v.y > maxY) maxY = v.y;
                }
                return { type: 'POLY', params: [maxX - minX, maxY - minY], vertices, rotation: 0 };
            } else if (code === 5) {
                // Polygon: 5,exposure,n_vertices,cx,cy,diameter,rotation
                const nVerts = parseInt(evalExpr(parts[2])) || 4;
                const d = evalExpr(parts[5]);
                const rot = evalExpr(parts[6]) || 0;
                return { type: 'P', params: [d, nVerts, rot], rotation: 0 };
            } else if (code === 20 || code === 2) {
                // Vector line: 20,exposure,width,x1,y1,x2,y2,rotation
                const w = evalExpr(parts[2]);
                return { type: 'C', params: [w], rotation: 0 };
            } else if (code === 21) {
                // Center rectangle: 21,exposure,width,height,cx,cy,rotation
                const w = evalExpr(parts[2]);
                const h = evalExpr(parts[3]);
                const rot = evalExpr(parts[6]) || 0;
                return { type: 'R', params: [w, h], rotation: rot };
            } else if (code === 22) {
                // Lower-left rectangle: 22,exposure,width,height,x,y,rotation
                const w = evalExpr(parts[2]);
                const h = evalExpr(parts[3]);
                const rot = evalExpr(parts[6]) || 0;
                return { type: 'R', params: [w, h], rotation: rot };
            }
        }
        
        // Fallback: if params look like width/height, use rectangle
        if (params.length >= 2 && params[0] > 0 && params[1] > 0) {
            const rot = params[2] || 0;
            return { type: 'R', params: [params[0], params[1]], rotation: rot };
        }
        
        return { type: 'C', params: [params[0] || 0.5], rotation: 0 };
    }
    
    arcToPoints(x1, y1, x2, y2, i, j, cw) {
        const cx = x1 + i, cy = y1 + j;
        const r = Math.sqrt(i * i + j * j);
        if (r < 0.0001) return [{ x: x2, y: y2 }];
        
        let a1 = Math.atan2(y1 - cy, x1 - cx);
        let a2 = Math.atan2(y2 - cy, x2 - cx);
        
        if (Math.abs(x1 - x2) < 0.01 && Math.abs(y1 - y2) < 0.01) {
            a2 = cw ? a1 - Math.PI * 2 : a1 + Math.PI * 2;
        } else {
            if (cw && a2 >= a1) a2 -= Math.PI * 2;
            if (!cw && a2 <= a1) a2 += Math.PI * 2;
        }
        
        const pts = [];
        const steps = Math.max(72, Math.ceil(Math.abs(a2 - a1) * r / 0.1));
        for (let n = 1; n <= steps; n++) {
            const a = a1 + (a2 - a1) * n / steps;
            pts.push({ x: cx + r * Math.cos(a), y: cy + r * Math.sin(a) });
        }
        return pts;
    }
    
    parseDrill(name, text, info) {
        const tools = {};
        let curTool = null;
        let unit = 'mm';
        let formatInt = 3, formatDec = 3;
        const cmds = [];
        let inHeader = true;
        
        const lines = text.split(/\r?\n/);
        
        for (const line of lines) {
            const l = line.trim();
            if (!l || l.startsWith(';')) continue;
            
            if (l === '%' || l === 'M95') { inHeader = false; continue; }
            if (l === 'M30' || l === 'M00') break;
            
            // Format from comment
            let m = l.match(/FILE_FORMAT=(\d):(\d)/i);
            if (m) { formatInt = +m[1]; formatDec = +m[2]; continue; }
            
            // Unit/format line
            m = l.match(/^(METRIC|INCH),?(LZ|TZ)?,?(\d+\.?\d*)?/i);
            if (m) {
                unit = m[1].toUpperCase() === 'INCH' ? 'in' : 'mm';
                if (m[3] && m[3].includes('.')) {
                    const parts = m[3].split('.');
                    formatInt = parts[0].length;
                    formatDec = parts[1].length;
                }
                continue;
            }
            
            // Tool definition
            m = l.match(/T(\d+)C([\d.]+)/i);
            if (m) {
                let dia = parseFloat(m[2]);
                if (unit === 'in') dia *= 25.4;
                tools[m[1]] = dia;
                tools[parseInt(m[1]).toString()] = dia;
                continue;
            }
            
            // Tool select
            m = l.match(/^T(\d+)$/i);
            if (m) {
                curTool = m[1];
                if (!tools[curTool]) curTool = parseInt(curTool).toString();
                continue;
            }
            
            if (inHeader) continue;
            
            // Slot
            m = line.match(/X([+-]?\d+)Y([+-]?\d+)G85X([+-]?\d+)Y([+-]?\d+)/i);
            if (m && curTool) {
                const div = Math.pow(10, formatDec);
                let x1 = parseInt(m[1]) / div;
                let y1 = parseInt(m[2]) / div;
                let x2 = parseInt(m[3]) / div;
                let y2 = parseInt(m[4]) / div;
                if (unit === 'in') { x1 *= 25.4; y1 *= 25.4; x2 *= 25.4; y2 *= 25.4; }
                cmds.push({ type: 'slot', x1, y1, x2, y2, diameter: tools[curTool] || 0.8 });
                continue;
            }
            
            // Drill
            m = line.match(/^X([+-]?\d+)Y([+-]?\d+)$/i);
            if (m && curTool) {
                const div = Math.pow(10, formatDec);
                let dx = parseInt(m[1]) / div;
                let dy = parseInt(m[2]) / div;
                if (unit === 'in') { dx *= 25.4; dy *= 25.4; }
                cmds.push({ type: 'drill', x: dx, y: dy, diameter: tools[curTool] || 0.8 });
            }
        }
        
        console.log(`[${name}] Drill: ${formatInt}.${formatDec}, Unit: ${unit}, Tools: ${Object.keys(tools).length}, Holes: ${cmds.length}`);
        return { name, ...info, cmds, visible: true };
    }
    
    extractBoardOutline() {
        const ol = this.layers.find(l => l.type === 'outline');
        if (!ol) { this.boardOutline = null; return; }
        
        const segments = [];
        for (const cmd of ol.cmds) {
            if (cmd.type === 'line') {
                segments.push({ x1: cmd.x1, y1: cmd.y1, x2: cmd.x2, y2: cmd.y2, used: false });
            } else if (cmd.type === 'arc') {
                const pts = this.arcToPoints(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.i, cmd.j, cmd.cw);
                let px = cmd.x1, py = cmd.y1;
                for (const p of pts) {
                    segments.push({ x1: px, y1: py, x2: p.x, y2: p.y, used: false });
                    px = p.x; py = p.y;
                }
            } else if (cmd.type === 'region' && cmd.points.length >= 3) {
                for (let i = 0; i < cmd.points.length - 1; i++) {
                    segments.push({ x1: cmd.points[i].x, y1: cmd.points[i].y, x2: cmd.points[i+1].x, y2: cmd.points[i+1].y, used: false });
                }
            }
        }
        
        if (!segments.length) { this.boardOutline = null; return; }
        
        const dist = (x1, y1, x2, y2) => Math.hypot(x2 - x1, y2 - y1);
        
        let current = segments[0];
        current.used = true;
        const path = [{ x: current.x1, y: current.y1 }, { x: current.x2, y: current.y2 }];
        let endX = current.x2, endY = current.y2;
        
        for (let iter = 0; iter < segments.length * 2; iter++) {
            let best = null, bestDist = Infinity, reversed = false;
            for (const seg of segments) {
                if (seg.used) continue;
                const d1 = dist(endX, endY, seg.x1, seg.y1);
                const d2 = dist(endX, endY, seg.x2, seg.y2);
                if (d1 < bestDist) { bestDist = d1; best = seg; reversed = false; }
                if (d2 < bestDist) { bestDist = d2; best = seg; reversed = true; }
            }
            if (!best || bestDist > 2) break;
            best.used = true;
            path.push({ x: reversed ? best.x1 : best.x2, y: reversed ? best.y1 : best.y2 });
            endX = reversed ? best.x1 : best.x2;
            endY = reversed ? best.y1 : best.y2;
        }
        
        this.boardOutline = path;
    }
    
    calcBounds() {
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        for (const l of this.layers) {
            for (const c of l.cmds) {
                const pts = c.points || (c.x !== undefined ? [{ x: c.x, y: c.y }] : [{ x: c.x1, y: c.y1 }, { x: c.x2, y: c.y2 }]);
                for (const p of pts) {
                    if (p.x < minX) minX = p.x;
                    if (p.y < minY) minY = p.y;
                    if (p.x > maxX) maxX = p.x;
                    if (p.y > maxY) maxY = p.y;
                }
            }
        }
        if (minX !== Infinity) this.bounds = { minX, minY, maxX, maxY };
    }
    
    updateStats() {
        if (!this.bounds) {
            document.getElementById('statSize').textContent = '-';
            document.getElementById('statHoles').textContent = '-';
            return;
        }
        
        const w = (this.bounds.maxX - this.bounds.minX).toFixed(1);
        const h = (this.bounds.maxY - this.bounds.minY).toFixed(1);
        document.getElementById('statSize').textContent = `${w} √ó ${h} mm`;
        
        const drillLayers = this.layers.filter(l => l.type === 'drill');
        if (drillLayers.length) {
            let totalDrills = 0, totalSlots = 0;
            const toolStats = {};
            
            for (const dl of drillLayers) {
                for (const c of dl.cmds) {
                    if (c.type === 'drill') {
                        totalDrills++;
                        const d = c.diameter.toFixed(2);
                        toolStats[d] = (toolStats[d] || 0) + 1;
                    } else if (c.type === 'slot') {
                        totalSlots++;
                    }
                }
            }
            
            document.getElementById('statHoles').textContent = totalDrills + (totalSlots ? ` + ${totalSlots} slot` : '');
            
            const tbody = document.querySelector('#drillTable tbody');
            tbody.innerHTML = Object.entries(toolStats)
                .sort((a, b) => parseFloat(a[0]) - parseFloat(b[0]))
                .map(([d, n], i) => `<tr><td>T${i+1}</td><td>${d}</td><td>${n}</td></tr>`)
                .join('');
            document.getElementById('drillTable').style.display = Object.keys(toolStats).length ? '' : 'none';
        } else {
            document.getElementById('statHoles').textContent = '-';
            document.getElementById('drillTable').style.display = 'none';
        }
    }
    
    fit() {
        if (!this.bounds) return;
        const rect = document.getElementById('canvasContainer').getBoundingClientRect();
        this.canvas2d.width = rect.width;
        this.canvas2d.height = rect.height;
        
        const bw = this.bounds.maxX - this.bounds.minX;
        const bh = this.bounds.maxY - this.bounds.minY;
        const sw = (rect.width - 80) / bw;
        const sh = (rect.height - 80) / bh;
        this.ppm = Math.min(sw, sh);
        this.zoom = 1;
        this.pan = { x: (rect.width - bw * this.ppm) / 2, y: (rect.height - bh * this.ppm) / 2 };
        this.updateZoomDisplay();
        this.render();
    }
    
    setZoom(z) {
        const old = this.zoom;
        this.zoom = Math.max(0.05, Math.min(50, z));
        const cx = this.canvas2d.width / 2, cy = this.canvas2d.height / 2;
        const s = this.zoom / old;
        this.pan.x = cx - (cx - this.pan.x) * s;
        this.pan.y = cy - (cy - this.pan.y) * s;
        this.updateZoomDisplay();
        this.render();
    }
    
    updateZoomDisplay() {
        document.getElementById('zoomDisplay').textContent = Math.round(this.zoom * 100) + '%';
    }
    
    setAllLayersVisible(v) {
        this.layers.forEach(l => l.visible = v);
        this.updateLayerList();
        this.render();
        if (this.viewMode === '3d') this.build3DModel();
    }
    
    render() {
        if (!this.bounds || !this.layers.length) return;
        
        const ctx = this.ctx;
        const scale = this.ppm * this.zoom;
        const bw = this.bounds.maxX - this.bounds.minX;
        const bh = this.bounds.maxY - this.bounds.minY;
        
        ctx.fillStyle = this.colors.bg;
        ctx.fillRect(0, 0, this.canvas2d.width, this.canvas2d.height);
        
        ctx.save();
        ctx.translate(this.pan.x, this.pan.y);
        ctx.scale(scale, scale);
        
        // Apply rotation and flip
        const cx = bw / 2, cy = bh / 2;
        ctx.translate(cx, cy);
        if (this.rotation) ctx.rotate(this.rotation * Math.PI / 180);
        if (this.flipH) ctx.scale(-1, 1);
        if (this.flipV) ctx.scale(1, -1);
        ctx.translate(-cx, -cy);
        ctx.translate(-this.bounds.minX, -this.bounds.minY);
        
        // Clip to board outline and fill FR4
        if (this.boardOutline?.length >= 3) {
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(this.boardOutline[0].x, this.boardOutline[0].y);
            for (let i = 1; i < this.boardOutline.length; i++) {
                ctx.lineTo(this.boardOutline[i].x, this.boardOutline[i].y);
            }
            ctx.closePath();
            ctx.clip();
            ctx.fillStyle = '#c19a6b';
            ctx.fill();
        }
        
        const sorted = [...this.layers].sort((a, b) => a.order - b.order);
        
        if (this.copperOnly) {
            for (const l of sorted) {
                if (l.visible && l.type === 'copper') this.renderLayer(l, ctx);
            }
        } else {
            // 1. Copper
            for (const l of sorted) {
                if (l.visible && l.type === 'copper') this.renderLayer(l, ctx);
            }
            
            // 2. Solder mask
            for (const l of sorted) {
                if (l.visible && l.type === 'mask') {
                    ctx.globalAlpha = 0.78;
                    this.renderSolderMask(l, ctx);
                    ctx.globalAlpha = 1;
                }
            }
            
            // 3. Silkscreen
            for (const l of sorted) {
                if (l.visible && l.type === 'silk') this.renderLayer(l, ctx);
            }
        }
        
        // 4. Drills
        for (const l of sorted) {
            if (l.visible && l.type === 'drill') this.renderDrillLayer(l, ctx);
        }
        
        if (this.boardOutline) ctx.restore();
        
        // Outline stroke
        const ol = this.layers.find(l => l.type === 'outline');
        if (ol?.visible && this.boardOutline) {
            ctx.strokeStyle = '#facc15';
            ctx.lineWidth = 0.15;
            ctx.beginPath();
            ctx.moveTo(this.boardOutline[0].x, this.boardOutline[0].y);
            for (let i = 1; i < this.boardOutline.length; i++) {
                ctx.lineTo(this.boardOutline[i].x, this.boardOutline[i].y);
            }
            ctx.closePath();
            ctx.stroke();
        }
        
        ctx.restore();
    }
    
    renderSolderMask(layer, ctx) {
        ctx.save();
        
        // Fill board with mask color
        if (this.boardOutline?.length >= 3) {
            ctx.fillStyle = layer.color;
            ctx.beginPath();
            ctx.moveTo(this.boardOutline[0].x, this.boardOutline[0].y);
            for (let i = 1; i < this.boardOutline.length; i++) {
                ctx.lineTo(this.boardOutline[i].x, this.boardOutline[i].y);
            }
            ctx.closePath();
            ctx.fill();
        }
        
        // Cut out all dark features (pad openings)
        ctx.globalCompositeOperation = 'destination-out';
        ctx.fillStyle = '#000';
        ctx.strokeStyle = '#000';
        
        for (const cmd of layer.cmds) {
            if (cmd.polarity === 'clear') continue;
            
            if (cmd.type === 'region' && cmd.points.length >= 3) {
                ctx.beginPath();
                ctx.moveTo(cmd.points[0].x, cmd.points[0].y);
                for (let i = 1; i < cmd.points.length; i++) {
                    ctx.lineTo(cmd.points[i].x, cmd.points[i].y);
                }
                ctx.closePath();
                ctx.fill();
            } else if (cmd.type === 'line') {
                ctx.lineWidth = cmd.width || 0.1;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(cmd.x1, cmd.y1);
                ctx.lineTo(cmd.x2, cmd.y2);
                ctx.stroke();
            } else if (cmd.type === 'flash') {
                this.drawFlash(ctx, cmd.x, cmd.y, cmd.aperture);
            }
        }
        
        ctx.restore();
    }
    
    renderLayer(layer, ctx) {
        for (const cmd of layer.cmds) {
            ctx.fillStyle = layer.color;
            ctx.strokeStyle = layer.color;
            ctx.globalCompositeOperation = cmd.polarity === 'clear' ? 'destination-out' : 'source-over';
            
            if (cmd.type === 'region' && cmd.points.length >= 3) {
                ctx.beginPath();
                ctx.moveTo(cmd.points[0].x, cmd.points[0].y);
                for (let i = 1; i < cmd.points.length; i++) {
                    ctx.lineTo(cmd.points[i].x, cmd.points[i].y);
                }
                ctx.closePath();
                ctx.fill();
            } else if (cmd.type === 'line') {
                ctx.lineWidth = cmd.width || 0.1;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(cmd.x1, cmd.y1);
                ctx.lineTo(cmd.x2, cmd.y2);
                ctx.stroke();
            } else if (cmd.type === 'arc') {
                ctx.lineWidth = cmd.width || 0.1;
                ctx.lineCap = 'round';
                const pts = this.arcToPoints(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.i, cmd.j, cmd.cw);
                ctx.beginPath();
                ctx.moveTo(cmd.x1, cmd.y1);
                for (const p of pts) ctx.lineTo(p.x, p.y);
                ctx.stroke();
            } else if (cmd.type === 'flash') {
                this.drawFlash(ctx, cmd.x, cmd.y, cmd.aperture);
            }
        }
        ctx.globalCompositeOperation = 'source-over';
    }
    
    renderDrillLayer(layer, ctx) {
        for (const cmd of layer.cmds) {
            if (cmd.type === 'drill') {
                ctx.globalCompositeOperation = 'source-over';
                ctx.fillStyle = this.colors.bg;
                ctx.beginPath();
                ctx.arc(cmd.x, cmd.y, cmd.diameter / 2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = this.colors.copper;
                ctx.lineWidth = 0.15;
                ctx.beginPath();
                ctx.arc(cmd.x, cmd.y, cmd.diameter / 2 + 0.15, 0, Math.PI * 2);
                ctx.stroke();
            } else if (cmd.type === 'slot') {
                ctx.globalCompositeOperation = 'source-over';
                ctx.strokeStyle = this.colors.copper;
                ctx.lineCap = 'round';
                ctx.lineWidth = cmd.diameter + 0.3;
                ctx.beginPath();
                ctx.moveTo(cmd.x1, cmd.y1);
                ctx.lineTo(cmd.x2, cmd.y2);
                ctx.stroke();
                
                ctx.strokeStyle = this.colors.bg;
                ctx.lineWidth = cmd.diameter;
                ctx.beginPath();
                ctx.moveTo(cmd.x1, cmd.y1);
                ctx.lineTo(cmd.x2, cmd.y2);
                ctx.stroke();
            }
        }
    }
    
    drawFlash(ctx, x, y, ap) {
        const t = ap.type;
        const p = ap.params;
        const rot = (ap.rotation || 0) * Math.PI / 180;
        
        ctx.save();
        ctx.translate(x, y);
        if (rot) ctx.rotate(rot);
        
        if (t === 'C') {
            ctx.beginPath();
            ctx.arc(0, 0, (p[0] || 0.5) / 2, 0, Math.PI * 2);
            ctx.fill();
        } else if (t === 'R') {
            const w = p[0] || 0.5;
            const h = p.length > 1 ? p[1] : w;
            ctx.fillRect(-w / 2, -h / 2, w, h);
        } else if (t === 'O') {
            const w = p[0] || 0.5;
            const h = p.length > 1 ? p[1] : w;
            ctx.beginPath();
            if (Math.abs(w - h) < 0.001) {
                ctx.arc(0, 0, w / 2, 0, Math.PI * 2);
            } else if (w > h) {
                const r = h / 2, dx = (w - h) / 2;
                ctx.moveTo(-dx, -r);
                ctx.lineTo(dx, -r);
                ctx.arc(dx, 0, r, -Math.PI / 2, Math.PI / 2);
                ctx.lineTo(-dx, r);
                ctx.arc(-dx, 0, r, Math.PI / 2, -Math.PI / 2);
            } else {
                const r = w / 2, dy = (h - w) / 2;
                ctx.moveTo(r, -dy);
                ctx.lineTo(r, dy);
                ctx.arc(0, dy, r, 0, Math.PI);
                ctx.lineTo(-r, -dy);
                ctx.arc(0, -dy, r, Math.PI, 0);
            }
            ctx.closePath();
            ctx.fill();
        } else if (t === 'P') {
            const od = p[0] || 0.5;
            const vertices = p[1] || 4;
            const pRot = (p[2] || 0) * Math.PI / 180;
            ctx.beginPath();
            for (let i = 0; i < vertices; i++) {
                const angle = pRot + (i * 2 * Math.PI / vertices);
                const px = (od / 2) * Math.cos(angle);
                const py = (od / 2) * Math.sin(angle);
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fill();
        } else if (t === 'POLY' && ap.vertices) {
            ctx.beginPath();
            ctx.moveTo(ap.vertices[0].x, ap.vertices[0].y);
            for (let i = 1; i < ap.vertices.length; i++) {
                ctx.lineTo(ap.vertices[i].x, ap.vertices[i].y);
            }
            ctx.closePath();
            ctx.fill();
        } else {
            // Fallback
            ctx.beginPath();
            ctx.arc(0, 0, (p[0] || 0.5) / 2, 0, Math.PI * 2);
            ctx.fill();
        }
        
        ctx.restore();
    }
    
    updateUI() {
        this.updateFileList();
        this.updateLayerList();
        document.getElementById('layerCount').textContent = this.layers.length;
    }
    
    updateFileList() {
        document.getElementById('fileList').innerHTML = this.files.map((f, i) => {
            const l = this.layers[i];
            return `<div class="file-item"><span class="file-tag ${l.type}">${l.type.slice(0,4)}</span><span class="file-name">${f.name}</span><button class="file-del" onclick="viewer.removeFile(${i})">√ó</button></div>`;
        }).join('');
    }
    
    updateLayerList() {
        document.getElementById('layerList').innerHTML = this.layers.length ? this.layers.map((l, i) => `
            <div class="layer-item" onclick="viewer.toggleLayer(${i})">
                <div class="layer-toggle ${l.visible ? 'on' : ''}"></div>
                <div class="layer-color" style="background:${l.color}"></div>
                <span class="layer-name">${l.name}</span>
            </div>`).join('') : '<div style="color:var(--text2);text-align:center;padding:16px">Nessun layer</div>';
    }
    
    toggleLayer(i) {
        this.layers[i].visible = !this.layers[i].visible;
        this.updateLayerList();
        this.render();
        if (this.viewMode === '3d') this.build3DModel();
    }
    
    removeFile(i) {
        this.files.splice(i, 1);
        this.layers.splice(i, 1);
        this.extractBoardOutline();
        this.calcBounds();
        this.updateUI();
        this.updateStats();
        if (!this.layers.length) {
            document.getElementById('emptyState').style.display = 'flex';
            this.canvas2d.style.display = 'none';
            this.canvas3d.style.display = 'none';
        } else {
            this.fit();
            if (this.viewMode === '3d') this.build3DModel();
        }
    }

    clear() {
        this.files = [];
        this.layers = [];
        this.bounds = null;
        this.boardOutline = null;
        this.updateUI();
        this.updateStats();
        document.getElementById('emptyState').style.display = 'flex';
        this.canvas2d.style.display = 'none';
        this.canvas3d.style.display = 'none';
        // Clear 3D scene
        if (this.pcbGroup) {
            while (this.pcbGroup.children.length > 0) {
                const child = this.pcbGroup.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(m => m.dispose());
                    } else {
                        child.material.dispose();
                    }
                }
                this.pcbGroup.remove(child);
            }
        }
    }

    exportPng() {
        if (!this.layers.length) return;
        const a = document.createElement('a');
        a.download = 'pcb.png';
        if (this.viewMode === '3d') {
            this.render3D();
            a.href = this.canvas3d.toDataURL('image/png');
        } else {
            a.href = this.canvas2d.toDataURL('image/png');
        }
        a.click();
    }
}

const viewer = new GerberViewer();
</script>
</body>
</html>
